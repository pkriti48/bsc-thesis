msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-18\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. ยง0: ```index```
#. ยง1: ```word_1```
#. ยง2: ```index```
#. ยง3: ```word_1 ++ word_2```
#. ยง4: ```word_1```
#. ยง5: ```word_2```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "Taking from an appended word beyond the left operand.\n"
"\n"
"If ยง0 is greater than the length of ยง1, then taking ยง2\n"
"characters from ยง3 yields all of ยง4 followed by the\n"
"remaining characters taken from ยง5."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```length```
#. ยง2: ```index```
#. ยง3: ```index โค length```
#. ยง4: ```index```
#. ยง5: ```replicateChar char length```
#. ยง6: ```length - index```
#. ยง7: ```char```
#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "Dropping a prefix from a word of repeated characters.\n"
"\n"
"For a character ยง0 and natural numbers ยง1 and ยง2 such that\n"
"ยง3, dropping ยง4 characters from ยง5\n"
"produces a word consisting of ยง6 copies of ยง7."
msgstr ""

#: Game.Levels.TakeAndDrop.L01_TakeAll
#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
#: Game.Levels.AnBnNotRegular.L02_CountAInReplicateCharA
#: Game.Levels.AnBnNotRegular.L02_CountAInReplicateCharA
#: Game.Levels.AnBnNotRegular.L02_CountAInReplicateCharA
#: Game.Levels.AnBnNotRegular.L02_CountAInReplicateCharA
#: Game.Levels.AnBnNotRegular.L03_CountBInReplicateCharA
#: Game.Levels.AnBnNotRegular.L03_CountBInReplicateCharA
#: Game.Levels.AnBnNotRegular.L03_CountBInReplicateCharA
#: Game.Levels.AnBnNotRegular.L04_TakeReplicateCharAppend
#: Game.Levels.AnBnNotRegular.L04_TakeReplicateCharAppend
#: Game.Levels.AnBnNotRegular.L04_TakeReplicateCharAppend
#: Game.Levels.AnBnNotRegular.L04_TakeReplicateCharAppend
#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
#: Game.Levels.AnBnNotRegular.L06_CountAInU
#: Game.Levels.AnBnNotRegular.L06_CountAInU
#: Game.Levels.AnBnNotRegular.L06_CountAInU
#: Game.Levels.AnBnNotRegular.L06_CountAInU
#: Game.Levels.AnBnNotRegular.L07_CountBInU
#: Game.Levels.AnBnNotRegular.L07_CountBInU
#: Game.Levels.AnBnNotRegular.L07_CountBInU
#: Game.Levels.AnBnNotRegular.L07_CountBInU
#: Game.Levels.AnBnNotRegular.L08_CountAInV
#: Game.Levels.AnBnNotRegular.L08_CountAInV
#: Game.Levels.AnBnNotRegular.L08_CountAInV
#: Game.Levels.AnBnNotRegular.L08_CountAInV
#: Game.Levels.AnBnNotRegular.L09_CountBInV
#: Game.Levels.AnBnNotRegular.L09_CountBInV
#: Game.Levels.AnBnNotRegular.L09_CountBInV
#: Game.Levels.AnBnNotRegular.L09_CountBInV
#: Game.Levels.AnBnNotRegular.L10_LengthZEq2n
#: Game.Levels.AnBnNotRegular.L10_LengthZEq2n
#: Game.Levels.AnBnNotRegular.L10_LengthZEq2n
#: Game.Levels.AnBnNotRegular.L10_LengthZEq2n
#: Game.Levels.AnBnNotRegular.L11_LengthPumpedWord
#: Game.Levels.AnBnNotRegular.L11_LengthPumpedWord
#: Game.Levels.AnBnNotRegular.L11_LengthPumpedWord
#: Game.Levels.AnBnNotRegular.L11_LengthPumpedWord
#: Game.Levels.AnBnNotRegular.L12_WEqRemainingAsNBs
#: Game.Levels.AnBnNotRegular.L12_WEqRemainingAsNBs
#: Game.Levels.AnBnNotRegular.L12_WEqRemainingAsNBs
#: Game.Levels.AnBnNotRegular.L12_WEqRemainingAsNBs
#: Game.Levels.AnBnNotRegular.L13_CountAInW
#: Game.Levels.AnBnNotRegular.L13_CountAInW
#: Game.Levels.AnBnNotRegular.L13_CountAInW
#: Game.Levels.AnBnNotRegular.L13_CountAInW
#: Game.Levels.AnBnNotRegular.L14_CountBInW
#: Game.Levels.AnBnNotRegular.L14_CountBInW
#: Game.Levels.AnBnNotRegular.L14_CountBInW
#: Game.Levels.AnBnNotRegular.L14_CountBInW
#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid ""
msgstr ""

#. ยง0: ```take_append_right```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "Well done! You just showed that ยง0 shows that when taking more\n"
"characters than are present in the first word, the result includes the entirety of the first\n"
"word plus the corresponding number of characters from the second word, correctly spanning the\n"
"boundary between the two. Let's move on to the last proof in the second world."
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#. ยง0: ```count_char_in_append```
#: Game.Levels.CountCharAndElemOf.L01_CountCharInAppend
msgid "The following statement ยง0 proves that the number of times a\n"
"character appears in the appended word is exactly the sum of its occurrences in each of the original\n"
"words."
msgstr ""

#. ยง0: ```word```
#. ยง1: ```char```
#. ยง2: ```length (concat word char) = length word + 1```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "The length of a word after concatenating a character is the length of the word plus one.\n"
"\n"
"For any ยง0 and character ยง1, ยง2.\n"
"This reflects the fact that concatenating a character to a word increases its length by one."
msgstr ""

#: Game.Levels.TakeAndDrop
msgid "Take and Drop"
msgstr ""

#. ยง0: ```simp [take]```
#. ยง1: ```simp```
#. ยง2: ```simp```
#. ยง3: ```take```
#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid "In order to solve the current goal, the easiest way to proceed is to execute\n"
"ยง0. As described earlier, the ยง1 tactic simplifies your current proof\n"
"goal using all function definitions and theorems that are curently available and have been\n"
"notated with the ยง2 keyword. In this case, it additionally uses the ยง3 function\n"
"to simplify the current proof goal further."
msgstr ""

#: Game.Levels.AppendAndConcat
msgid "Append and Concat"
msgstr ""

#. ยง0: ```m```
#. ยง1: ```n```
#. ยง2: ```k```
#. ยง3: ```k```
#. ยง4: ```m```
#. ยง5: ```n```
#. ยง6: ```(m + k) - (n + k) = m - n```
#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "Cancel a common addend on the right of a subtraction.\n"
"\n"
"For any natural numbers ยง0, ยง1, and ยง2, adding the same number ยง3 to\n"
"both ยง4 and ยง5 does not change their difference:\n"
"ยง6."
msgstr ""

#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "Very good! Let's move forward to the next level where you will show how how the length\n"
"of a word changes when it is repeated multiple times."
msgstr ""

#. ยง0: ```โw```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "Very good! Next, you will show the ยง0 property for any second word or right word in\n"
"the append function."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L04_CharInAppendRight
msgid "Element of Second Word is Element of Appended Word"
msgstr ""

#. ยง0: ```n```
#. ยง1: ```m```
#. ยง2: ```k```
#. ยง3: ```(n + m) + k = n + (m + k)```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Addition is associative.\n"
"\n"
"For all natural numbers ยง0, ยง1, and ยง2, we have\n"
"ยง3."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n * 0 = 0```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Zero is an absorbing element for multiplication.\n"
"\n"
"For any natural number ยง0, we have ยง1."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```zero```
#. ยง2: ```replicateChar```
#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "You first prove the statement for the case, where ยง0 has the value ยง1 and\n"
"you start by rewriting the ยง2 function."
msgstr ""

#. ยง0: ```char```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Now, you can simplify your current proof goal by rewriting the concatenation of a ยง0\n"
"to a non-empty word."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: ```=```
#. ยง1: ```rfl```
#. ยง2: ```1 + 0 = 1 + 0```
#. ยง3: ```=```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Now, you see very similar terms on both sides of the ยง0 sign but they are not equal\n"
"yet. That means, you can not use the ยง1 tactic yet. To use the tactic, the expression\n"
"has to have the form ยง2. Since you have an addition on both sides of the\n"
"ยง3 sign, you can use the commutative property of the mathematical addition and proceed\n"
"accordingly."
msgstr ""

#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "Length of Character Replicas"
msgstr ""

#. ยง0: ```length_replicateChar```
#. ยง1: ```char```
#. ยง2: ```n```
#. ยง3: ```replicateChar```
#. ยง4: ```n```
#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "The theorem ยง0 describes the length of a word created by\n"
"repeating a single character multiple times. It states that if a character ยง1 is\n"
"repeated ยง2 times using ยง3, the resulting word has length exactly ยง4."
msgstr ""

#. ยง0: ```replicateChar input_char n```
#. ยง1: ```input_char```
#: Game.Levels.CountCharAndElemOf.L05_CharInReplicateChar
msgid "In this level, you will show that if any character appears in a word formed by\n"
"ยง0, then that character and ยง1 must be equal.\n"
"\n"
"In other words, you will prove that a word made of repeating a specifif character cannot\n"
"contain any other character."
msgstr ""

#. ยง0: ```=```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Using the mathematical property of associativity, you can simplify the current expression\n"
"and reach the equality between the expressions on both sides of the ยง0 sign."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```n```
#. ยง2: ```replicateChar char n```
#. ยง3: ```n```
#. ยง4: ```char```
#. ยง5: ```n```
#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "The length of a word formed by repeating a character.\n"
"\n"
"For any character ยง0 and natural number ยง1, ยง2\n"
"produces a word consisting of ยง3 copies of ยง4. The length of this\n"
"word is exactly ยง5."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```word_1```
#. ยง2: ```index```
#. ยง3: ```word_1 ++ word_2```
#. ยง4: ```index - length word_1```
#. ยง5: ```word_2```
#: Game.Levels.TakeAndDrop.L06_DropAppendRight
msgid "Dropping from an appended word beyond the left operand.\n"
"\n"
"If ยง0 is greater than the length of ยง1, then dropping ยง2\n"
"characters from ยง3 is the same as dropping\n"
"ยง4 characters from ยง5."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```word_1```
#. ยง2: ```word_2```
#. ยง3: ```char```
#. ยง4: ```word_1 ++ word_2```
#. ยง5: ```word_1```
#. ยง6: ```word_2```
#. ยง7: ```char```
#. ยง8: ```word_1```
#. ยง9: ```word_2```
#: Game.Levels.CountCharAndElemOf.L01_CountCharInAppend
msgid "Counting characters distributes over word append.\n"
"\n"
"For any character ยง0 and words ยง1 and ยง2, the number of\n"
"occurrences of ยง3 in the word ยง4 generated by appending\n"
"ยง5 and ยง6 is the sum of the numbers of occurrences of ยง7\n"
"in ยง8 and in ยง9."
msgstr ""

#. ยง0: ```word```
#. ยง1: ```nil```
#. ยง2: ```cons head tail```
#. ยง3: ```head```
#. ยง4: ```tail```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "You should start with induction on ยง0 so that you can prove the statement for the\n"
"empty word ยง1 and for any non-empty word ยง2, where the non-empty word\n"
"corresponds to a character (ยง3) prepended to a word (ยง4)."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```left```
#. ยง2: ```left ++ right```
#. ยง3: ```right```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "Character membership is preserved under append on the left word.\n"
"\n"
"If a character ยง0 appears in the word ยง1, then it also appears\n"
"in the appended word ยง2 for any word ยง3."
msgstr ""

#: Game
msgid "The Pumping Lemma Game"
msgstr ""

#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "In this level, you will prove that the operation of appending two words adds their\n"
"lengths together. The resulting word contains exactly as many characters as the first word plus\n"
"the second."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```word_1```
#. ยง2: ```index```
#. ยง3: ```word_1 ++ word_2```
#. ยง4: ```index - length word_1```
#. ยง5: ```word_2```
#: Game.Levels.TakeAndDrop.L06_DropAppendRight
msgid "In this level, you will prove that if ยง0 is greater than the length\n"
"of ยง1, then dropping ยง2 characters from ยง3 is\n"
"equivalent to dropping ยง4 characters from ยง5 alone."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```replicateChar char length```
#. ยง2: ```index```
#. ยง3: ```length```
#. ยง4: ```index```
#. ยง5: ```char```
#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "In this level, you will prove that if you take ยง0 characters from\n"
"ยง1, where ยง2 does not exceed ยง3, the result is\n"
"a word consisting of exactly ยง4 copies of the character ยง5."
msgstr ""

#. ยง0: ```word```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Similar to the previous level, you should start with  induction on ยง0."
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```index```
#. ยง2: ```word_1 ++ word_2```
#. ยง3: ```index```
#. ยง4: ```word_1```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Taking from an appended word within the left operand.\n"
"\n"
"If the number of characters taken does not exceed the length of ยง0,\n"
"then taking ยง1 characters from ยง2 is the same as taking\n"
"ยง3 characters from ยง4 alone."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "In this level, you will showthat if a word is repeated ยง0 times, the length\n"
"of the resulting word is equal to ยง1 multiplied by the length of the original word,\n"
"reflecting the additive effect of appending the same word repeatedly."
msgstr ""

#. ยง0: ```drop_replicateChar```
#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "Well done! Now, let's go forward and prove the counterpart of this theorem, which is\n"
"the theorem ยง0."
msgstr ""

#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "You can start with this proof the same way as you did in the previous proof."
msgstr ""

#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "Appending Two Replicas of a Single Character Adds Their Counts"
msgstr ""

#. ยง0: ```char```
#. ยง1: ```m```
#. ยง2: ```n```
#. ยง3: ```replicateChar char m```
#. ยง4: ```replicateChar char n```
#. ยง5: ```replicateChar char (m + n)```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "Appending two words consisting of repeated instances of the same character.\n"
"\n"
"For a character ยง0 and natural numbers ยง1 and ยง2, appending\n"
"ยง3 with ยง4 produces a word\n"
"equivalent to ยง5."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L05_CharInReplicateChar
msgid "All Characters in a Word Formed By Replicating a Characters are Same"
msgstr ""

#. ยง0: ```take_append_right```
#: Game.Levels.TakeAndDrop.L06_DropAppendRight
msgid "The proof for this statement is very similar to the proof for ยง0. If\n"
"you do not know how to proceed, you can follow the schema of the previous proof."
msgstr ""

#. ยง0: ```split```
#. ยง1: ```char = char_count```
#. ยง2: ```char โ char_count```
#: Game.Levels.CountCharAndElemOf.L02_CountCharInReplicateChar
msgid "You can ยง0 your current proof goal at this point. Then, you will prove the outcome\n"
"for the two cases ยง1 and ยง2."
msgstr ""

#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Prepending a Character Increases Word Length by One"
msgstr ""

#. ยง0: ```index โค 0```
#. ยง1: ```index = 0```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Your induction hypothesis is currently ยง0. However, you know that index is a\n"
"natural number, that cannot be less than 0. That means, you have to derive ยง1 from\n"
"the current expression."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```right```
#. ยง2: ```left ++ right```
#. ยง3: ```left```
#: Game.Levels.CountCharAndElemOf.L04_CharInAppendRight
msgid "Character membership is preserved under append on the right.\n"
"\n"
"If a character ยง0 appears in the word ยง1, then it also appears\n"
"in the appended word ยง2 for any word ยง3."
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```word_2```
#. ยง2: ```word_2```
#. ยง3: ```index โฅ length word_1```
#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "Very good! You just proved that dropping characters in ยง0 and then\n"
"appending ยง1 leaves ยง2 unaffected. Let's move on to proving the corresponding\n"
"theorems for take and drop for ยง3."
msgstr ""

#: Game
msgid "A playful way to learn about the Pumping Lemma"
msgstr ""

#: Game.Levels.CountCharAndElemOf.L04_CharInAppendRight
msgid "Very good! Now, let's proceed towards the last proof of this world!"
msgstr ""

#. ยง0: ```countCharInWord```
#. ยง1: ```elemOf```
#. ยง2: ```append```
#. ยง3: ```replicateChar```
#. ยง4: ```countCharInWord```
#. ยง5: ```elemOf```
#. ยง6: ```elemOf char word```
#. ยง7: ```char โw word```
#: Game.Levels.CountCharAndElemOf
msgid "Welcome to **The CountChar and ElemOf World**!\n"
"\n"
"In this world, you will study the behavior of the functions ยง0 and ยง1\n"
"in combination with the functions ยง2 and ยง3:\n"
"- ยง4 returns the number of occurrences of a given character in a word.\n"
"- ยง5 determines whether a character is in a word or not. ยง6 can\n"
"also be written as ยง7 and the property holds if and only if the given character\n"
"appears in that word at least once.\n"
"\n"
"You will first prove that counting the occurrences of a character in word generated by the append\n"
"function preserves the counts from individual words and sums them up.\n"
"You will then analyze how character counting behaves in words formed by repeating a single character.\n"
"\n"
"Following this, you will establish that character membership is preserved under appending, both when a\n"
"character appears in the left word and when it appears in the right word.\n"
"Finally, you will prove that character membership is also preserved for character replicas.\n"
"\n"
"Let's get started!"
msgstr ""

#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "Length of a Word Connected to Another Word"
msgstr ""

#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid "Take All Characters of a Word"
msgstr ""

#: Game.Levels.CountCharAndElemOf.L01_CountCharInAppend
msgid "Count Occurrences of a Character in an Appended Word"
msgstr ""

#. ยง0: ```index```
#. ยง1: ```replicateChar char length```
#. ยง2: ```index```
#. ยง3: ```length```
#. ยง4: ```length - index```
#. ยง5: ```char```
#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "In this level, you will prove that if you drop ยง0 characters from\n"
"ยง1, where ยง2 does not exceed ยง3, the result is\n"
"a word consisting of exactly ยง4 copies of the character ยง5."
msgstr ""

#. ยง0: ```n + 1```
#. ยง1: ```succ n```
#. ยง2: ```Nat.succ_eq_add_one```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Now, you can transform any term of the form ยง0 into\n"
"ยง1 by using the theorem ยง2."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```char_count```
#. ยง2: ```n```
#. ยง3: ```char_count```
#. ยง4: ```replicateChar char n```
#. ยง5: ```n```
#. ยง6: ```0```
#: Game.Levels.CountCharAndElemOf.L02_CountCharInReplicateChar
msgid "Counting characters in a word of repeated characters.\n"
"\n"
"For characters ยง0 and ยง1 and a natural number ยง2,\n"
"counting occurrences of ยง3 in ยง4\n"
"returns ยง5 if the two characters are equal, and ยง6 otherwise."
msgstr ""

#. ยง0: ```drop```
#: Game.Levels.TakeAndDrop.L02_DropAll
msgid "Well done! You just proved that using the ยง0 function with the full length\n"
"of a word removes all characters, leaving no remaining characters. Let's move forward!"
msgstr ""

#. ยง0: ```take_append_right```
#. ยง1: ```index```
#. ยง2: ```word_1```
#. ยง3: ```index```
#. ยง4: ```word_1 ++
#. word_2```
#. ยง5: ```index - length word_1```
#. ยง6: ```word_2```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "The following theorem ยง0 states that if ยง1 is\n"
"greater than the length of ยง2, then taking ยง3 characters from ยง4 results in all of wordโ followed by the first ยง5 characters\n"
"of ยง6."
msgstr ""

#. ยง0: ```length_replicateWord```
#. ยง1: ```n```
#. ยง2: ```n```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "By proving the theorem ยง0, you confirmed that repeating a\n"
"word ยง1 times produces a word whose length is exactly ยง2 times the length of the\n"
"original word. Now, let's go over to the last level of this world!"
msgstr ""

#. ยง0: ```word_1```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "You should start with induction over ยง0 in this proof."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L02_CountCharInReplicateChar
msgid "Well done! You just proved that a word formed by repeating a single character\n"
"contains exactly as many occurrences of that character as its repetition count, and none of any\n"
"other character."
msgstr ""

#. ยง0: ```simp```
#. ยง1: ```simp```
#. ยง2: ```exact```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "The ยง0 tactic simplifies your current proof goal using all function definitions\n"
"and theorems that are currently available and have been notated with the ยง1 keyword.\n"
"And, the ยง2 tactic can be applied to a proof goal that matches with an induction\n"
"hypothesis character by character."
msgstr ""

#. ยง0: ```take```
#. ยง1: ```drop```
#. ยง2: ```take```
#. ยง3: ```drop```
#. ยง4: ```take```
#. ยง5: ```nil```
#. ยง6: ```take```
#. ยง7: ```drop```
#. ยง8: ```word_1```
#. ยง9: ```word_1 ++ word_2```
#. ยง10: ```word_1```
#. ยง11: ```word_2```
#. ยง12: ```word_1
#. ++ word_2```
#. ยง13: ```word_1```
#. ยง14: ```word_2```
#. ยง15: ```word_1
#. ++ word_2```
#. ยง16: ```word_2```
#. ยง17: ```word_1 ++ word_2```
#. ยง18: ```take```
#. ยง19: ```drop```
#. ยง20: ```replicateChar```
#: Game.Levels.TakeAndDrop
msgid "Welcome to the second world of this game: **The Take and Drop World**!\n"
"\n"
"Here, you will study the behavior of the functions ยง0 and ยง1 on words and their\n"
"interaction with word appending.\n"
"\n"
"The ยง2 function returns a prefix of a given word consisting of the character upto the\n"
"specified index, while the ยง3 function returns a suffix of a given word consisting of the\n"
"characters starting at the given index.\n"
"\n"
"You will start by proving, that the function ยง4 returns the word itself when the index\n"
"corresponds to the length of the given word. At the same time, with the same value for the index,\n"
"the drop function returns the empty word ยง5.\n"
"\n"
"Following this, you will analyze how ยง6 and ยง7 behave when combined with the append\n"
"function:\n"
"- The prefix to be returned of a given word lies in ยง8 for ยง9.\n"
"- The suffix to be returned of a given word lies in both ยง10 and ยง11 for ยง12.\n"
"- The prefix to be returned of a given word lies in both ยง13 and ยง14 for ยง15.\n"
"- The suffix to be returned of a given word lies in ยง16 for  ยง17.\n"
"\n"
"Lastly, you will analyze how ยง18 and ยง19 behave when combined with the function\n"
"ยง20.\n"
"\n"
"Let's start!"
msgstr ""

#: Game.Levels.CountCharAndElemOf
msgid "CountChar and ElemOf"
msgstr ""

#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Length of Word Replicas"
msgstr ""

#. ยง0: ```nil```
#. ยง1: ```word```
#. ยง2: ```word ++ nil = word```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "Appending the empty word ยง0 to any word results in the word itself.\n"
"\n"
"For any word ยง1, ยง2. This reflects the identity\n"
"property of the empty word in word concatenation."
msgstr ""

#: Game
msgid "Welcome to the Pumping Lemma Game!\n"
"\n"
"In this game, we build a definition of a language in terms of formal languages. For this language,\n"
"we prove various facts about appending two words or concating a character to a word, etc.\n"
"These lemmas are then used to build the Pumping Lemma for regular languages.\n"
"Finally, this Pumping Lemma is applied to some languages to show that those languages are not regular.\n"
"\n"
"This game should help you to dig deep into the definition of the Pumping Lemma. It should help you\n"
"to understand the Pumping Lemma better by deriving several facts you might not think of when writing\n"
"the proof on paper.\n"
"\n"
"Good luck and enjoy learning about the Pumping Lemma!"
msgstr ""

#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "Appending an Empty Word Preserves the Original Word"
msgstr ""

#. ยง0: ```Nat.mul_zero```
#. ยง1: ```Nat.mul_succ```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Similar to simplifying by using ยง0 in the previous proof goal, you can use\n"
"ยง1 here."
msgstr ""

#. ยง0: ```take```
#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid "You did it! You just showed that if you use the ยง0 function with the full\n"
"length of a word, no characters are omitted, and the resulting word is exactly the same as the\n"
"original. Let's move on to the next proof!"
msgstr ""

#. ยง0: ```simp```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "You can also use the ยง0 tactic at this point."
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```word_2```
#. ยง2: ```word_1 ++ word_2```
#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "The length of joining two words.\n"
"\n"
"For any words ยง0 and ยง1, the length of their append\n"
"ยง2 is the sum of their lengths."
msgstr ""

#. ยง0: ```nil```
#. ยง1: ```word```
#. ยง2: ```word```
#. ยง3: ```append_nil```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "You will start playing the game by proving that appending the empty word\n"
"ยง0 to any ยง1 leaves ยง2 unchanged.\n"
"\n"
"Basically, the theorem ยง3 states the identity property of nil in word concatenation."
msgstr ""

#. ยง0: ```=```
#. ยง1: ```k```
#. ยง2: ```length tail```
#. ยง3: ```Nat.succ_sub_succ```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "In order to reach equality between the terms on both sides of the ยง0 sign, you can cancel the\n"
"successors of both ยง1 and ยง2 using the theorem ยง3."
msgstr ""

#. ยง0: ```nil :: char```
#. ยง1: ```nil```
#. ยง2: ```concat nil char```
#. ยง3: ```rewrite [concat]```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "The term ยง0 in your current proof goal corresponds to concatenating a given\n"
"character to the empty word ยง1, this is a notation for writing ยง2 in\n"
"user friendly way. So, you can simplify this expression by executing ยง3."
msgstr ""

#. ยง0: ```rfl```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "In order to prove this proof goal, you can execute the ยง0 tactic."
msgstr ""

#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid "In this level, you will provef: This theorem states that taking a number of\n"
"characters equal to the length of a word returns the word itself."
msgstr ""

#. ยง0: ```append_nil```
#. ยง1: ```word ++ nil```
#. ยง2: ```word```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "ยง0 establishes that the empty word acts as a neutral element for word\n"
"appending: adding it to the end of any word leaves the word unchanged. Using this lemma, you\n"
"can simplify any term of the form ยง1 to the term ยง2 in any upcoming\n"
"level. Let's move on to the next proof!"
msgstr ""

#. ยง0: ```simp```
#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "You can also use the ยง0 tactic to solve the current proof goal in one single step instead of\n"
"solving it in multiple steps."
msgstr ""

#. ยง0: ```Nat.le_zero_eq```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "You can simplify your current induction hypothesis using the theorem\n"
"ยง0."
msgstr ""

#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "Drop from a Sequence of Repeated Characters"
msgstr ""

#. ยง0: ```n```
#. ยง1: ```Nat.succ n```
#. ยง2: ```n + 1```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "The successor of a natural number is adding one.\n"
"\n"
"For any natural number ยง0, ยง1 is equal to ยง2."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```0 + n = n```
#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "Zero is the left identity of addition.\n"
"\n"
"For any natural number ยง0, we have ยง1.the following:"
msgstr ""

#. ยง0: ```m```
#. ยง1: ```n```
#. ยง2: ```m + n```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "In this level, you will show that if you append two words formed by replicating\n"
"the same character โ one repeated ยง0 times and the other repeated ยง1 times โ the\n"
"resulting word corresponds to ยง2 replicas of that same character."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L02_CountCharInReplicateChar
msgid "In the following, you will prove that the result of counting occurrences of a character\n"
"in a word formed by a character's replicas solely depends on whether the character being counted matches\n"
"the repeated one. If they are the same, the count equals the number of repetitions; otherwise, the\n"
"count is zero."
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```word_1```
#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "In this level, you start with an induction on ยง0 so that you can easily prove the\n"
"statement for all possible values of ยง1."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Again, you have to prove the statement for all possible values of ยง0. So, you start\n"
"with induction on ยง1 as you did in the previous level."
msgstr ""

#: Game.Levels.TakeAndDrop.L02_DropAll
msgid "Drop All Characters of a Word"
msgstr ""

#. ยง0: ```a```
#. ยง1: ```b```
#. ยง2: ```Nat.succ b```
#. ยง3: ```Nat.succ a```
#. ยง4: ```b```
#. ยง5: ```a```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "Subtracting successors cancels on both sides.\n"
"\n"
"For any natural numbers ยง0 and ยง1, subtracting ยง2 from\n"
"ยง3 is the same as subtracting ยง4 from ยง5."
msgstr ""

#: Game
msgid "*Game Version: 1.0*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage.\n"
"If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local storage\n"
"(or \"local site data\"). Make sure to download your game progress first!"
msgstr ""

#. ยง0: ```Show more help!```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "If you do not know how to proceed, click on the ยง0 button!"
msgstr ""

#. ยง0: ```word_2```
#. ยง1: ```take_append_left```
#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "Contrary to the previous proof, an induction over ยง0 is necessary at this point.\n"
"Otherwise, the procedure is pretty similar to the proof of ยง1."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n```
#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "Since you have to prove the statement for all possible values of ยง0, you should\n"
"start by induction on ยง1."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L02_CountCharInReplicateChar
msgid "Count Occurrences of a Character in Word Formed by a Character's Replicas"
msgstr ""

#. ยง0: ```length```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "At this point, you have to simplify your current proof goal as much as you can by\n"
"rewriting using the ยง0 function."
msgstr ""

#. ยง0: ```drop_all```
#. ยง1: ```nil```
#: Game.Levels.TakeAndDrop.L02_DropAll
msgid "In this level, you will prove the theorem ยง0. It states that dropping\n"
"a number of characters equal to the length of a word results in the empty word ยง1."
msgstr ""

#. ยง0: ```length_append```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Here, you can use the ยง0 theorem, you proved in Level 3, to\n"
"simplify your current goal."
msgstr ""

#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "Very good! You just proved that appending words preserves all characters from both\n"
"operands, with the total length of the resulting word being exactly the sum of their individual\n"
"lengths. From now onwards, you can rewrite both terms to one another whenever necessary."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```word```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "In this level, you will prove that concatenating a character ยง0 to the\n"
"end of a ยง1 increases its length by one.\n"
"\n"
"Specifically, the length of word :: char is equal to the length of word plus one."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "The following proof states that character membership is preserved when a word is appended\n"
"to another. Precisely, if a character appears in the left word, then it also appears in the word formed\n"
"by appending any right word to it."
msgstr ""

#. ยง0: ```Take and Drop```
#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "With this, you have successfully proven all the goals of the ยง0\n"
"World. You are getting closer to executing the pumping lemma on concrete languages. Let's move\n"
"on to the third world!"
msgstr ""

#. ยง0: ```char```
#. ยง1: ```length```
#. ยง2: ```index```
#. ยง3: ```index โค length```
#. ยง4: ```index```
#. ยง5: ```replicateChar char length```
#. ยง6: ```index```
#. ยง7: ```char```
#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "Taking a prefix of repeated characters.\n"
"\n"
"For a character ยง0 and natural numbers ยง1 and ยง2 such that\n"
"ยง3, taking ยง4 characters from ยง5\n"
"produces a word consisting of ยง6 copies of ยง7."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```index```
#. ยง2: ```word_1```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "The ยง0 variable in your induction hypothesis should not be\n"
"fixed at this point. In order to have a general variable ยง1, you should have\n"
"declared it as such when you started the induction over ยง2."
msgstr ""

#. ยง0: ```Nat.succ a โค Nat.succ b```
#. ยง1: ```a โค b```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Cancel successors from both sides of an inequality.\n"
"\n"
"If ยง0, then ยง1."
msgstr ""

#: Game
msgid "In this game, you prove some facts about the Language structure specifically defined\n"
"for this game and later on other facts about the Pumping Lemma. Finally, you use these lemmas to\n"
"prove that the provided examples fo languages are not regular languages."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```m```
#. ยง2: ```n```
#. ยง3: ```Nat.succ m```
#. ยง4: ```n```
#. ยง5: ```n * m```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Multiplication by a successor.\n"
"\n"
"For any natural numbers ยง0 and ยง1, multiplying ยง2 by ยง3\n"
"is equal to adding ยง4 to ยง5."
msgstr ""

#. ยง0: ```take```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "You just proved that the second word does not influence the result when taking a\n"
"number of characters within the bounds of the first word, allowing ยง0 to focus solely on\n"
"the first word. Well done! Let's move to the level 4!"
msgstr ""

#. ยง0: ```countCharInWord```
#. ยง1: ```append```
#. ยง2: ```countCharInWord```
#. ยง3: ```replicateChar```
#: Game.Levels.CountCharAndElemOf.L01_CountCharInAppend
msgid "Very good! You just how ยง0 behaves in combination with the ยง1\n"
"function. Now, let's move over to showing the behavior of ยง2 in combination with\n"
"ยง3."
msgstr ""

#. ยง0: ```drop_append_right```
#: Game.Levels.TakeAndDrop.L06_DropAppendRight
msgid "By proving the theorem ยง0, you showed that when dropping more\n"
"characters than the first word contains, the entire first word is removed, and the remaining\n"
"characters are taken from the second word, effectively continuing the drop into the suffix. Now,\n"
"let's move forward to the next level!"
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n + 0 = a```
#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "Zero is the right identity of addition.\n"
"\n"
"For any natural number ยง0, we have ยง1."
msgstr ""

#. ยง0: ```word```
#. ยง1: ```length word```
#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid "Taking the full length of a word returns the word itself.\n"
"\n"
"For any word ยง0, taking ยง1 characters yields the original\n"
"word unchanged."
msgstr ""

#. ยง0: ```h```
#. ยง1: ```h```
#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "As you can see, your current proof goal and the hypothesis ยง0 represent a very\n"
"similar fact. You can now either transform ยง1 such that it is equal to the current proof\n"
"goal or vice versa."
msgstr ""

#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Well done! You just demonstrated that extending a word by one character results in\n"
"a word whose length is precisely one greater than before. Let's move on to the next proof!"
msgstr ""

#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "You did it! You successfully resolved all proof goals in the level 1. Let's move on\n"
"to World 2."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "Element of Left Word is Element of Appended Word"
msgstr ""

#. ยง0: ```$L = {a^n b^n |
#. n โฅ 0}$```
#. ยง1: ```a```
#. ยง2: ```b```
#. ยง3: ```a```
#. ยง4: ```a```
#. ยง5: ```b```
#. ยง6: ```take```
#. ยง7: ```replicateChar a n
#. ++ replicateChar b n```
#. ยง8: ```index```
#. ยง9: ```k```
#. ยง10: ```k โค n```
#. ยง11: ```k```
#. ยง12: ```a```
#. ยง13: ```(u ++ v) = replicateChar
#. a (length (u ++ v))```
#. ยง14: ```a```
#. ยง15: ```b```
#. ยง16: ```u```
#. ยง17: ```v```
#. ยง18: ```z = u ++ v ++ w```
#. ยง19: ```z```
#. ยง20: ```w```
#. ยง21: ```n - (length (u ++ v))```
#. ยง22: ```a```
#. ยง23: ```n```
#. ยง24: ```b```
#. ยง25: ```a```
#. ยง26: ```b```
#. ยง27: ```$L = {a^n b^n | n โฅ 0}$```
#: Game.Levels.AnBnNotRegular
msgid "Wuhuu! You have finally reached the final world of the game.\n"
"\n"
"So far, you proved many theorem that will now come handy to prove that the language ยง0 is not regular.\n"
"\n"
"You will start by proving that the count of ยง1s and ยง2s has to be the same in word if the\n"
"word is an element of the language L as defined above.\n"
"\n"
"Then, you will proceed by proving that the number of ยง3s in a replica of ยง4s corresponds to\n"
"the word's length and the number of ยง5s in such a word is 0.\n"
"\n"
"Following this, you will prove that applying the ยง6 function to any word ยง7 with the ยง8 set to ยง9 and ยง10 corresponds to ยง11\n"
"replicas of the character  ยง12. Using this theorem, you will prove that ยง13 and use this fact in the following proofs.\n"
"\n"
"Next, you will prove how many ยง14s and ยง15s each occur in the words ยง16 and ยง17 with\n"
"ยง18 and statements regarding the length of any word ยง19 and the pumped word.\n"
"\n"
"Thereafter, you will prove that the word ยง20 consists of ยง21 ยง22s\n"
"and ยง23 ยง24s.\n"
"\n"
"Then almost reaching the end, you will prove that the pumped word consists of more ยง25s than\n"
"ยง26s and finally, you will show that the language ยง27 is not regular."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```char```
#. ยง2: ```input_char```
#. ยง3: ```n```
#. ยง4: ```char```
#. ยง5: ```input_char```
#: Game.Levels.CountCharAndElemOf.L05_CharInReplicateChar
msgid "Character membership in a replicated-character word.\n"
"\n"
"For any character ยง0, if ยง1 appears in a word formed by repeating\n"
"ยง2 exactly ยง3 times, then ยง4 must be equal to ยง5."
msgstr ""

#. ยง0: ```simp```
#. ยง1: ```exact```
#. ยง2: ```rfl```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "At this point, you can simplify the proof goal by using the induction hypothesis, as\n"
"you would do in any proof by induction for the non-base case. For that, you have two\n"
"possibilities to proceed from this step. You can either proceed by executing the ยง0\n"
"tactic followed by ยง1 tactic combined with the induction hypothesis or you rewrite\n"
"the induction hypothesis and then execute ยง2."
msgstr ""

#. ยง0: ```โจ```
#. ยง1: ```right```
#: Game.Levels.CountCharAndElemOf.L04_CharInAppendRight
msgid "As you can observe in your current proof goal, the term on the right-hand side of the\n"
"ยง0 matches your induction hypothesis. So, you can retrieve it by using the keyword\n"
"ยง1 and then proceed with the proof."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#. ยง0: ```n โค 0```
#. ยง1: ```n = 0```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "A natural number less than or equal to zero is zero.\n"
"\n"
"If ยง0, then ยง1."
msgstr ""

#. ยง0: ```m```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "You can start with an induction on ยง0, as it is mostly easier to proceed from left to right."
msgstr ""

#. ยง0: ```word```
#. ยง1: ```length word```
#: Game.Levels.TakeAndDrop.L02_DropAll
msgid "Dropping the full length of a word yields the empty word.\n"
"\n"
"For any word ยง0, dropping ยง1 characters removes all\n"
"characters, resulting in the empty word."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L04_CharInAppendRight
msgid "The goal of this level is to prove that character membership is preserved when a\n"
"word is appended to another. Precisely, if a character appears in the right word, then it also\n"
"appears in the word formed by appending this word to any word on its left."
msgstr ""

#. ยง0: ```append```
#. ยง1: ```=```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "As you did in the first proof goal, you can start with rewriting the ยง0\n"
"function. This rewrites the term on the left-hand side of the ยง1 sign into ```cons head\n"
"(tail ++ nil)."
msgstr ""

#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Taking Characters Within the First Word of an Appended Word"
msgstr ""

#. ยง0: ```index```
#. ยง1: ```word_1```
#. ยง2: ```index```
#. ยง3: ```word_1 ++ word_2```
#. ยง4: ```index```
#. ยง5: ```word_1```
#. ยง6: ```word_2```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "In this level, you will prove that if the number of characters ยง0 to take\n"
"does not exceed the length of the first word ยง1, then taking ยง2 characters\n"
"from ยง3 is equivalent to taking ยง4 characters from ยง5\n"
"alone. The second word ยง6 has no effect in this case."
msgstr ""

#. ยง0: ```A```
#. ยง1: ```B```
#. ยง2: ```anBnLang```
#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
msgid "The Number of ยง0s is Equal to the Number of ยง1s in ยง2"
msgstr ""

#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "Taking Characters Beyond the First Word in an Appended Word"
msgstr ""

#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "Take from a Sequence of Repeated Characters"
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```word_2```
#. ยง2: ```index```
#. ยง3: ```word_2```
#. ยง4: ```index```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "At this point, you are observing the non empty case of ยง0 and your proof goal\n"
"right now has two more values of an inductive type: ยง1 and ยง2. However, you\n"
"do not need to observe ยง3 as you want to transform the left-hand side term such that\n"
"word_2 does not occur in it anymore. So you proceed by observing all possible values of\n"
"ยง4."
msgstr ""

#: Game.Levels.TakeAndDrop.L06_DropAppendRight
msgid "Dropping Characters Beyond the First Word in an Appended Word"
msgstr ""

#. ยง0: ```a```
#. ยง1: ```b```
#. ยง2: ```Nat.succ a + b```
#. ยง3: ```Nat.succ (a + b)```
#. ยง4: ```b```
#. ยง5: ```a```
#. ยง6: ```b```
#. ยง7: ```a```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "The successor of a natural number added to another number.\n"
"\n"
"For any natural numbers ยง0 and ยง1, ยง2 is equal to\n"
"ยง3. This expresses that adding ยง4 after taking the\n"
"successor of ยง5 is equivalent to taking the successor after adding ยง6 to ยง7."
msgstr ""

#. ยง0: ```elemOf```
#. ยง1: ```A โจ B```
#. ยง2: ```left```
#. ยง3: ```right```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "As you already observed in the previous steps, the ยง0 function returns a clause\n"
"of the form ยง1. For your current proof goal, it means that you can access any of the\n"
"clauses by using the respective tactics ยง2 or ยง3 and observe them individually."
msgstr ""

#. ยง0: ```k + 1 โค 1 + tail.length```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Bring either the hypothesis ยง0 in the same form as your\n"
"current proof goal, or vice versa."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```word_1```
#. ยง2: ```index```
#. ยง3: ```word_1 ++ word_2```
#. ยง4: ```index```
#. ยง5: ```word_1```
#. ยง6: ```word_2```
#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "In this level, you will prove that if the number of characters to drop ยง0\n"
"does not exceed the length of the first word ยง1, then dropping ยง2 characters\n"
"from ยง3 is equivalent to dropping ยง4 characters from ยง5\n"
"and then appending the second word ยง6."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```m```
#. ยง2: ```n + m = n + m```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Addition is commutative.\n"
"\n"
"For all natural numbers ยง0 and ยง1, we have ยง2."
msgstr ""

#. ยง0: ```replicateChar```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "Now, you can rewrite the term on the right using ยง0."
msgstr ""

#. ยง0: ```=```
#. ยง1: ```replicateChar char (k + 1 + n)```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "To reach an equality between the terms on both sides of the ยง0 sign, start by\n"
"transforming ยง1 to an expression which can be easily\n"
"processed further."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```index โค length```
#. ยง2: ```length = 0```
#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "As already discussed earlier, ยง0 is a natural number so it cannot be 0. Thus, it has to\n"
"be 0 when ยง1 and ยง2."
msgstr ""

#. ยง0: ```length```
#. ยง1: ```length```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Basically you can memorize, that you start simplifying your expression from the most inner\n"
"term as you can see here. You simplified the concatenation first and now you are gonna simplify\n"
"the terms containing the ยง0 function. For that, you can simplify your current proof\n"
"goal by rewriting the ยง1 function."
msgstr ""

#. ยง0: ```append```
#. ยง1: ```concat```
#. ยง2: ```replicateChar```
#. ยง3: ```replicateWord```
#. ยง4: ```append```
#. ยง5: ```concat```
#. ยง6: ```replicateChar```
#. ยง7: ```n```
#. ยง8: ```replicateWord```
#. ยง9: ```n```
#. ยง10: ```nil```
#. ยง11: ```append```
#. ยง12: ```concat```
#. ยง13: ```replicateChar```
#. ยง14: ```replicateWord```
#: Game.Levels.AppendAndConcat
msgid "Welcome to **The Append and Concat World**!\n"
"\n"
"In this world, you will investigate the properties of the functions ยง0, ยง1,\n"
"ยง2, and ยง3:\n"
"- The function ยง4 takes two words and produces a new word consisting of the characters\n"
"of the first word followed by the characters of the second word.\n"
"- ยง5 adds a single character to the end of a word.\n"
"- ยง6 produces a new word by replicating a given character ยง7 times.\n"
"- ยง8 produces a new word by appending a given word to itself ยง9 times\n"
"\n"
"The first objective of this world is to establish that appending the empty word ยง10\n"
"to any word leaves that word unchanged.\n"
"\n"
"Next, you will analyze how the length of a word behaves under ยง11 and ยง12.\n"
"\n"
"Finally, building upon these lemmas, you will prove the lengths of words formed using the functions\n"
"ยง13 and ยง14.\n"
"\n"
"Let's get started!"
msgstr ""

#. ยง0: ```index```
#. ยง1: ```induction```
#. ยง2: ```cases```
#. ยง3: ```induction```
#. ยง4: ```cases```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "To observe all possible values of ยง0, you can either proceed\n"
"with ยง1 or with the ยง2 tactic. In comparison with ยง3,\n"
"ยง4 does not produce any (induction) hypothesis."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L05_CharInReplicateChar
msgid "Well done! One more step closer to executing the pumping lemma on concrete languages. Let's\n"
"move on to the next world!"
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```index```
#. ยง2: ```word_1 ++ word_2```
#. ยง3: ```index```
#. ยง4: ```word_1```
#. ยง5: ```word_2```
#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "Dropping from an appended word within the left operand.\n"
"\n"
"If the number of characters dropped does not exceed the length of ยง0,\n"
"then dropping ยง1 characters from ยง2 is the same as\n"
"dropping ยง3 characters from ยง4 and then appending ยง5."
msgstr ""

#. ยง0: ```h```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "Now, you can proceed by simplifying your hypothesis ยง0. Any other simplification is\n"
"currently not possible with the given theorems."
msgstr ""

#. ยง0: ```drop_replicateChar```
#. ยง1: ```take_replicateChar```
#. ยง2: ```take_replicateChar```
#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "The proof for ยง0 is analogue to the proof for the counterpart\n"
"ยง1. If you do not know how to proceed you can have a look at the\n"
"proof for ยง2 in the previous level."
msgstr ""

#. ยง0: ```intros h```
#. ยง1: ```->```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "You can split the implication in the current expression by executing ยง0. This\n"
"creates an induction hypothesis using the term on the left-hand side of the ยง1 sign and\n"
"creates a proof goal out of the term on the right-hand side."
msgstr ""

#. ยง0: ```rewrite```
#. ยง1: ```nil ++ nil = nil```
#. ยง2: ```rewrite [append]```
#. ยง3: ```nil```
#. ยง4: ```nil```
#. ยง5: ```nil = nil```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "So far, you have seen how an expression can be simplified using the ยง0 tactic\n"
"and a theorem if you have played the Natural Number Game. Now, you will see that you can\n"
"combine this tactic also with function definitions: You can simplify your current proof state\n"
"ยง1 by executing the tactic ยง2, as it corresponds to\n"
"appending an empty word ยง3 with another empty word ยง4. The result is then the\n"
"equation ยง5."
msgstr ""

#. ยง0: ```h```
#. ยง1: ```A โจ B```
#. ยง2: ```elemOf```
#. ยง3: ```cases```
#. ยง4: ```h```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "If you now observe ยง0, you see that it is a clause of the form ยง1. So, to\n"
"prove the statement for all possible return values of ยง2, you can proceed with\n"
"executing the ยง3 tactic with the hypothesis ยง4."
msgstr ""

#. ยง0: ```word```
#. ยง1: ```n```
#. ยง2: ```replicateWord word n```
#. ยง3: ```n```
#. ยง4: ```word```
#. ยง5: ```n```
#. ยง6: ```word```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "The length of a word repeated multiple times.\n"
"\n"
"For any word ยง0 and natural number ยง1, ยง2\n"
"produces a word consisting of ยง3 copies of ยง4 appended together.\n"
"The length of this resulting word is ยง5 times the length of ยง6."
msgstr ""

#: Game.Levels.AnBnNotRegular
msgid "AnBn is Not Regular"
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n - 0 = n```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "Subtracting zero from a natural number.\n"
"\n"
"For any natural number ยง0, we have ยง1."
msgstr ""

#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "Dropping Characters Within the First Word of an Appended Word"
msgstr ""
