msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-22\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. ยง0: $z = a^n b^n$
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```i = 2```
#. ยง3: ```a```
#. ยง4: ```v```
#. ยง5: ```n + length v```
#. ยง6: ```a```
#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "In this proof, you will show that after pumping the word ยง0, which is\n"
"decomposed as ยง1, using ยง2 the number of ยง3s increases in\n"
"the word. To be specific, it increases by the factor equal to the length of the middle word\n"
"ยง4. That means, the pumped word finally contains ยง5 ยง6s."
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
msgid "More as than bs"
msgstr ""

#: Game.Levels.TakeAndDrop
msgid "Take and Drop"
msgstr ""

#. ยง0: ```char```
#. ยง1: ```word_1```
#. ยง2: ```word_2```
#. ยง3: ```char```
#. ยง4: ```word_1 ++ word_2```
#. ยง5: ```word_1```
#. ยง6: ```word_2```
#. ยง7: ```char```
#. ยง8: ```word_1```
#. ยง9: ```word_2```
#: Game.Levels.CountCharAndElemOf.L01_CountCharInAppend
msgid "For any character ยง0 and words ยง1 and ยง2, the number of\n"
"occurrences of ยง3 in the word ยง4 generated by appending\n"
"ยง5 and ยง6 is the sum of the numbers of occurrences of ยง7\n"
"in ยง8 and in ยง9."
msgstr ""

#. ยง0: ```โw```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "Very good! Next, you will show the ยง0 property for any second word or right word in\n"
"the append function."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L04_CharInAppendRight
msgid "Element of Second Word is Element of Appended Word"
msgstr ""

#. ยง0: ```char```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Now, you can simplify your current proof goal by rewriting the concatenation of a ยง0\n"
"to a non-empty word."
msgstr ""

#. ยง0: ```=```
#. ยง1: ```rfl```
#. ยง2: ```1 + 0 = 1 + 0```
#. ยง3: ```=```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Now, you see very similar terms on both sides of the ยง0 sign but they are not equal\n"
"yet. That means, you can not use the ยง1 tactic yet. To use the tactic, the expression\n"
"has to have the form ยง2. Since you have an addition on both sides of the\n"
"ยง3 sign, you can use the commutative property of the mathematical addition and proceed\n"
"accordingly."
msgstr ""

#. ยง0: ```w```
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```n```
#. ยง3: ```b```
#: Game.Levels.AnBnNotRegular.L14_CountBInW
msgid "Using the theorem proved in level 12, you will show that the suffix ยง0\n"
"of ยง1 contains ยง2 ยง3s."
msgstr ""

#. ยง0: ```word```
#. ยง1: ```length word```
#: Game.Levels.TakeAndDrop.L02_DropAll
msgid "For any word ยง0, dropping ยง1 characters removes all\n"
"characters, resulting in the empty word."
msgstr ""

#. ยง0: ```=```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Using the mathematical property of associativity, you can simplify the current expression\n"
"and reach the equality between the expressions on both sides of the ยง0 sign."
msgstr ""

#. ยง0: ```cases```
#. ยง1: ```rcases```
#. ยง2: ```rcases```
#. ยง3: ```n```
#. ยง4: ```h_n```
#. ยง5: ```h_word```
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid "To remove the quantifiers, you can use the ยง0 tactic and simplify the hypothesis\n"
"manually as far as required/possible or you can use the ยง1 tactic which simplifies the\n"
"hypothesis recursively as far as possible. When using ยง2, you can specify the names of\n"
"the new hypothesis and expressions to be introduced. You could use the following names:  ยง3,\n"
"ยง4, ยง5."
msgstr ""

#. ยง0: ```word```
#. ยง1: ```nil```
#. ยง2: ```cons head tail```
#. ยง3: ```head```
#. ยง4: ```tail```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "You should start with induction on ยง0 so that you can prove the statement for the\n"
"empty word ยง1 and for any non-empty word ยง2, where the non-empty word\n"
"corresponds to a character (ยง3) prepended to a word (ยง4)."
msgstr ""

#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "This statement can mostly be proven using theorems about the associative and the commutative\n"
"property of natural numbers. It is quite a straightforward proof."
msgstr ""

#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "Length of Pumped Word (i = 2) is (n + length v)"
msgstr ""

#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "In this level, you will prove that the operation of appending two words adds their\n"
"lengths together. The resulting word contains exactly as many characters as the first word plus\n"
"the second."
msgstr ""

#. ยง0: ```w```
#. ยง1: ```a```
#. ยง2: ```b```
#: Game.Levels.AnBnNotRegular.L14_CountBInW
msgid "Again, you start by rewriting the word ยง0 as a sequence of ยง1s followed by a\n"
"sequence of ยง2s and proceed accordingly thereafter."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```b```
#. ยง2: ```n```
#. ยง3: ```a```
#. ยง4: ```2 * n```
#: Game.Levels.AnBnNotRegular.L10_LengthZEq2n
msgid "Th word produced by appending ยง0 replicas of ยง1 to ยง2\n"
"replicas of ยง3 has the length ยง4."
msgstr ""

#: Game.Levels.AnBnNotRegular.L06_CountAInU
msgid "The Prefix u Consists Only of as"
msgstr ""

#: Game.Levels.AnBnNotRegular.L09_CountBInV
msgid "The Middle Word v Does Not Contain any bs"
msgstr ""

#. ยง0: ```word```
#. ยง1: ```n```
#. ยง2: ```n * length word```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "In this level, you will show that if a ยง0 is repeated ยง1 times, the\n"
"length of the resulting word is equal to ยง2."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```word```
#. ยง2: ```length (word :: char) =
#.   length word + 1```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "In this level, you will prove that concatenating a character ยง0 to the\n"
"end of a ยง1 increases its length by one, which can be written as ยง2."
msgstr ""

#. ยง0: ```word```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Similar to the previous level, you should start with  induction on ยง0."
msgstr ""

#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "You can start with this proof the same way as you did in the previous proof."
msgstr ""

#. ยง0: ```drop_replicateChar```
#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "Well done! Now, let's go forward and prove the counterpart of this theorem, which is\n"
"the theorem ยง0."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```left```
#. ยง2: ```left ++ right```
#. ยง3: ```right```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
#: Game.Levels.CountCharAndElemOf.L04_CharInAppendRight
msgid "If a character ยง0 appears in the word ยง1, then it also appears\n"
"in the appended word ยง2 for any word ยง3."
msgstr ""

#. ยง0: ```b```
#. ยง1: ```u```
#: Game.Levels.AnBnNotRegular.L06_CountAInU
msgid "Well done! Next, you will show, how man ยง0s occur in the word ยง1."
msgstr ""

#. ยง0: ```take_append_right```
#: Game.Levels.TakeAndDrop.L06_DropAppendRight
msgid "The proof for this statement is very similar to the proof for ยง0. If\n"
"you do not know how to proceed, you can follow the schema of the previous proof."
msgstr ""

#. ยง0: ```m```
#. ยง1: ```n```
#. ยง2: ```k```
#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "States ommutativity on the left operands for addition on natural numbers.\n"
"\n"
"For natural numbers ยง0, ยง1, and ยง2, it asserts that:\n"
"m + (n + k) = n + (m + k)"
msgstr ""

#. ยง0: ```index โค 0```
#. ยง1: ```index = 0```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Your induction hypothesis is currently ยง0. However, you know that index is a\n"
"natural number, that cannot be less than 0. That means, you have to derive ยง1 from\n"
"the current expression."
msgstr ""

#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid "Take All Characters of a Word"
msgstr ""

#: Game.Levels.CountCharAndElemOf.L01_CountCharInAppend
msgid "Count Occurrences of a Character in an Appended Word"
msgstr ""

#. ยง0: ```n + 1```
#. ยง1: ```succ n```
#. ยง2: ```Nat.succ_eq_add_one```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Now, you can transform any term of the form ยง0 into\n"
"ยง1 by using the theorem ยง2."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n - n = 0```
#: Game.Levels.AnBnNotRegular.L13_CountAInW
msgid "Subtracting any natural number from itself.\n"
"\n"
"For any natural number ยง0, it means: ยง1."
msgstr ""

#. ยง0: ```length_replicateWord```
#. ยง1: ```n```
#. ยง2: ```n```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "By proving the theorem ยง0, you confirmed that repeating a\n"
"word ยง1 times produces a word whose length is exactly ยง2 times the length of the\n"
"original word. Now, let's go over to the last level of this world!"
msgstr ""

#: Game.Levels.CountCharAndElemOf.L05_CharInReplicateChar
msgid "Well done! One more step closer to executing the pumping lemma on concrete languages.\n"
"Let's move on to the next and final world!"
msgstr ""

#. ยง0: ```char```
#. ยง1: ```length```
#. ยง2: ```index```
#. ยง3: ```index โค length```
#. ยง4: ```index```
#. ยง5: ```replicateChar char length```
#. ยง6: ```index```
#. ยง7: ```char```
#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "For a character ยง0 and natural numbers ยง1 and ยง2 such that\n"
"ยง3, taking ยง4 characters from ยง5\n"
"produces a word consisting of ยง6 replicas of ยง7."
msgstr ""

#. ยง0: ```simp```
#. ยง1: ```simp```
#. ยง2: ```exact```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "The ยง0 tactic simplifies your current proof goal using all function definitions\n"
"and theorems that are currently available and have been notated with the ยง1 keyword.\n"
"And, the ยง2 tactic can be applied to a proof goal that matches with an induction\n"
"hypothesis character by character."
msgstr ""

#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Length of Word Replicas"
msgstr ""

#: Game.Levels.CountCharAndElemOf
msgid "CountChar and ElemOf"
msgstr ""

#: Game.Levels.AnBnNotRegular.L02_CountAInReplicateCharA
msgid "Well done! Let's move forward to the next proof!"
msgstr ""

#. ยง0: ```Nat.mul_zero```
#. ยง1: ```Nat.mul_succ```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Similar to simplifying by using ยง0 in the previous proof goal, you can use\n"
"ยง1 here."
msgstr ""

#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "Appending an Empty Word Preserves the Original Word"
msgstr ""

#. ยง0: ```take```
#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid "You did it! You just showed that if you use the ยง0 function with the full\n"
"length of a word, no characters are omitted, and the resulting word is exactly the same as the\n"
"original. Let's move on to the next proof!"
msgstr ""

#. ยง0: ```intro```
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid "As you can see, the hypothesis you created using ยง0 is not in its simplest form\n"
"yet. In order to simplify it further, remove all quantifiers you can."
msgstr ""

#. ยง0: ```m```
#. ยง1: ```n```
#. ยง2: ```b > 0```
#. ยง3: ```m + n > n```
#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
msgid "Adding a positive natural number to another natural number strictly increases it.\n"
"\n"
"For natural numbers ยง0 and ยง1 with ยง2, it asserts: ยง3"
msgstr ""

#. ยง0: ```simp```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "You can also use the ยง0 tactic at this point."
msgstr ""

#. ยง0: ```=```
#. ยง1: ```k```
#. ยง2: ```length tail```
#. ยง3: ```Nat.succ_sub_succ```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "In order to reach equality between the terms on both sides of the ยง0 sign, you can cancel the\n"
"successors of both ยง1 and ยง2 using the theorem ยง3."
msgstr ""

#. ยง0: ```a```
#. ยง1: ```b```
#. ยง2: ```Nat.succ a + b```
#. ยง3: ```Nat.succ (a + b)```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "The successor of a natural number added to another number.\n"
"\n"
"For any natural numbers ยง0 and ยง1, ยง2 is equal to\n"
"ยง3."
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```index```
#. ยง2: ```word_1 ++ word_2```
#. ยง3: ```index```
#. ยง4: ```word_1```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "If the number of characters taken does not exceed the length of ยง0,\n"
"then taking ยง1 characters from ยง2 is the same as taking\n"
"ยง3 characters from ยง4 alone."
msgstr ""

#. ยง0: ```nil```
#. ยง1: ```word```
#. ยง2: ```word```
#. ยง3: ```append_nil```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "You will start playing the game by proving that appending the empty word\n"
"ยง0 to any ยง1 leaves ยง2 unchanged.\n"
"\n"
"Basically, the theorem ยง3 states the identity property of nil when appending\n"
"words to one another."
msgstr ""

#. ยง0: ```append_nil```
#. ยง1: ```word ++ nil```
#. ยง2: ```word```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "ยง0 establishes that the empty word acts as a neutral element for word\n"
"appending: adding it to the end of any word leaves the word unchanged. Using this lemma, you\n"
"can simplify any term of the form ยง1 to the term ยง2 in any upcoming\n"
"level. Let's move on to the next proof!"
msgstr ""

#. ยง0: ```count_a_in_replicateChar_a```
#: Game.Levels.AnBnNotRegular.L03_CountBInReplicateCharA
msgid "This proof is analogue to the proof for the theorem ยง0. So, if\n"
"at any point, you do not know how to proceed, you can have a look at that proof."
msgstr ""

#. ยง0: ```Nat.le_zero_eq```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "You can simplify your current induction hypothesis using the theorem\n"
"ยง0."
msgstr ""

#. ยง0: ```a```
#. ยง1: ```b```
#. ยง2: ```w```
#: Game.Levels.AnBnNotRegular.L13_CountAInW
msgid "In the previous level, you showed how many ยง0s and ยง1s occur in the word ยง2,\n"
"you can use that theorem to simplify your current proof goal."
msgstr ""

#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "Drop from a Sequence of Repeated Characters"
msgstr ""

#. ยง0: ```word```
#. ยง1: ```n```
#. ยง2: ```replicateWord word n```
#. ยง3: ```n```
#. ยง4: ```word```
#. ยง5: ```n * length word```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "For any word ยง0 and natural number ยง1, ยง2\n"
"produces a new word consisting of ยง3 replicas of ยง4. The length of\n"
"this resulting word is ยง5."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L04_CharInAppendRight
msgid "The goal of this level is to prove that if a character appears in the right word,\n"
"then it also appears in the word formed by appending this word to any other word."
msgstr ""

#. ยง0: ```z```
#. ยง1: ```anBnLang```
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid "At this point, you choose your word ยง0 with that you are gonna prove that ยง1\n"
"is not regular."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Again, you have to prove the statement for all possible values of ยง0. So, you start\n"
"with induction on ยง1 as you did in the previous level."
msgstr ""

#. ยง0: $z = a^n b^n$
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```k = length u + length v```
#. ยง3: ```k โค n```
#. ยง4: ```length (u ++ v) โค n```
#. ยง5: ```length v โฅ 1```
#. ยง6: ```z_pumped = (u ++ (replicateWord v 2)) ++ w```
#. ยง7: ```more_as_than_bs```
#. ยง8: ```a```
#. ยง9: ```b```
#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
msgid "Given a word ยง0 and a decomposition ยง1 with\n"
"ยง2, ยง3, ยง4,\n"
"ยง5, and a pumped word ยง6,\n"
"ยง7 shows that the pumped word contains more ยง8s than ยง9s."
msgstr ""

#. ยง0: ```a```
#. ยง1: ```b```
#. ยง2: ```Nat.succ b```
#. ยง3: ```Nat.succ a```
#. ยง4: ```b```
#. ยง5: ```a```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "Subtracting successors cancels on both sides.\n"
"\n"
"For any natural numbers ยง0 and ยง1, subtracting ยง2 from\n"
"ยง3 is the same as subtracting ยง4 from ยง5."
msgstr ""

#: Game.Levels.TakeAndDrop.L02_DropAll
msgid "Drop All Characters of a Word"
msgstr ""

#: Game
msgid "*Game Version: 1.0*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage.\n"
"If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local storage\n"
"(or \"local site data\"). Make sure to download your game progress first!"
msgstr ""

#: Game.Levels.AnBnNotRegular.L08_CountAInV
msgid "The Middle Word v Consists Only of as"
msgstr ""

#. ยง0: ```word_2```
#. ยง1: ```take_append_left```
#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "Contrary to the previous proof, an induction over ยง0 is necessary at this point.\n"
"Otherwise, the procedure is pretty similar to the proof of ยง1."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n```
#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "Since you have to prove the statement for all possible values of ยง0, you should\n"
"start by induction on ยง1."
msgstr ""

#. ยง0: ```length```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "At this point, you have to simplify your current proof goal as much as you can by\n"
"rewriting using the ยง0 function."
msgstr ""

#. ยง0: ```length_append```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Here, you can use the ยง0 theorem, you proved in Level 3, to\n"
"simplify your current goal."
msgstr ""

#. ยง0: ```z = $a^n b^n$```
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```u ++ v```
#. ยง3: ```n```
#. ยง4: ```u```
#. ยง5: ```a```
#. ยง6: ```a```
#. ยง7: ```u```
#. ยง8: ```u```
#: Game.Levels.AnBnNotRegular.L06_CountAInU
#: Game.Levels.AnBnNotRegular.L08_CountAInV
msgid "If a word ยง0 is decomposed as ยง1 and the length of ยง2\n"
"is at most ยง3, then  ยง4 consists only of ยง5s. That means, the the number of occurrences\n"
"of ยง6 in ยง7 is equal to the length of ยง8."
msgstr ""

#. ยง0: ```z = $a^n b^n$```
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```u ++ v```
#. ยง3: ```n```
#. ยง4: ```u```
#. ยง5: ```a```
#. ยง6: ```b```
#. ยง7: ```u```
#: Game.Levels.AnBnNotRegular.L07_CountBInU
#: Game.Levels.AnBnNotRegular.L09_CountBInV
msgid "In this level, you will show that when you decompose the word ยง0 as\n"
"ยง1 and the length of ยง2 is at most ยง3, then ยง4 is made of\n"
"only ยง5s. Following this, the count of ยง6s in ยง7 is equal to 0."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "The following proof states that character membership is preserved when a word is appended\n"
"to another. Precisely, if a character appears in the left word, then it also appears in the word formed\n"
"by appending any right word to it."
msgstr ""

#. ยง0: ```w```
#. ยง1: ```z```
#. ยง2: ```w```
#: Game.Levels.AnBnNotRegular.L12_WEqRemainingAsNBs
msgid "If you do not know, how to retrieve the word ยง0 form the word ยง1,\n"
"you can do that by dropping all the characters occurring before the word ยง2."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```index```
#. ยง2: ```word_1```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "The ยง0 variable in your induction hypothesis should not be\n"
"fixed at this point. In order to have a general variable ยง1, you should have\n"
"declared it as such when you started the induction over ยง2."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```n```
#. ยง2: ```replicateChar char n```
#. ยง3: ```n```
#. ยง4: ```char```
#. ยง5: ```n```
#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "For any character ยง0 and natural number ยง1, ยง2\n"
"produces a word consisting of ยง3 replicas of ยง4. The length of this\n"
"word is exactly ยง5."
msgstr ""

#. ยง0: $L = {a^n b^n
#. | n โฅ 0}$
#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
msgid "Very good! Now, you will use this theorem in the final proof and show that ยง0 is not regular."
msgstr ""

#: Game.Levels.AnBnNotRegular.L07_CountBInU
msgid "The Prefix u Does Not Contain any bs"
msgstr ""

#. ยง0: ```drop```
#: Game.Levels.TakeAndDrop.L02_DropAll
msgid "Well done! You just proved that using the ยง0 function with the full length\n"
"of a word removes all characters. Let's move forward!"
msgstr ""

#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
msgid "Well done! You are getting closer to the final proof! Let's move on to the next\n"
"proof!"
msgstr ""

#: Game.Levels.CountCharAndElemOf.L02_CountCharInReplicateChar
msgid "Well done! You just proved that a word formed by replicating a specific character\n"
"contains exactly as many occurrences of that character as its repetition count, and none of any\n"
"other character."
msgstr ""

#. ยง0: ```take_append_right```
#. ยง1: ```index```
#. ยง2: ```word_1```
#. ยง3: ```index```
#. ยง4: ```word_1 ++ word_2```
#. ยง5: ```word_1```
#. ยง6: ```index - length word_1```
#. ยง7: ```word_2```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "The theorem ยง0 states that if ยง1 is greater than\n"
"the length of ยง2, then taking ยง3 characters from ยง4\n"
"results in all of ยง5 followed by the first ยง6 characters\n"
"of ยง7."
msgstr ""

#. ยง0: ```anBnLang```
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid "Next, you can introduce your pumped word, show that it is an element of ยง0 and\n"
"finally derive the contradiction."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n + 0 = a```
#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "Zero is the right identity of addition.\n"
"\n"
"For any natural number ยง0, we have ยง1."
msgstr ""

#. ยง0: ```index - length
#. word_1```
#: Game.Levels.TakeAndDrop.L06_DropAppendRight
msgid "By proving this theorem, you showed that when dropping more characters than the\n"
"first word contains, the entire first word is removed along with the first ยง0 characters from the second word. Now, let's move forward to the next level!"
msgstr ""

#: Game.Levels.AnBnNotRegular.L10_LengthZEq2n
msgid "Length of z Is 2 * n"
msgstr ""

#. ยง0: $z = a^n b^n$
#. ยง1: ```i = 2```
#. ยง2: ```z = (u ++ v) ++ w```
#. ยง3: ```k = length u + length v```
#. ยง4: ```k โค n```
#. ยง5: ```a```
#. ยง6: ```length v```
#. ยง7: ```a```
#. ยง8: ```n + length v```
#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "Pumping a word ยง0 using ยง1, which is decomposed as\n"
"ยง2, with ยง3 and ยง4,\n"
"increases the number of ยง5s occurring in the word by the factor\n"
"ยง6. So, the final length of the prefix consisting of ยง7s\n"
"is ยง8."
msgstr ""

#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "You did it! You successfully resolved all proof goals in the level 1. Let's move on\n"
"to World 2."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "Element of Left Word is Element of Appended Word"
msgstr ""

#. ยง0: $L = {a^n b^n |
#. n โฅ 0}$
#. ยง1: ```a```
#. ยง2: ```b```
#. ยง3: ```a```
#. ยง4: ```a```
#. ยง5: ```b```
#. ยง6: ```take```
#. ยง7: ```replicateChar a n
#. ++ replicateChar b n```
#. ยง8: ```index```
#. ยง9: ```k```
#. ยง10: ```k โค n```
#. ยง11: ```k```
#. ยง12: ```a```
#. ยง13: ```(u ++ v) = replicateChar
#. a (length (u ++ v))```
#. ยง14: ```a```
#. ยง15: ```b```
#. ยง16: ```u```
#. ยง17: ```v```
#. ยง18: ```z = u ++ v ++ w```
#. ยง19: ```z```
#. ยง20: ```w```
#. ยง21: ```n - (length (u ++ v))```
#. ยง22: ```a```
#. ยง23: ```n```
#. ยง24: ```b```
#. ยง25: ```a```
#. ยง26: ```b```
#. ยง27: $L = {a^n b^n | n โฅ 0}$
#: Game.Levels.AnBnNotRegular
msgid "Wuhuu! You have finally reached the final world of the game.\n"
"\n"
"So far, you proved many theorem that will now come handy to prove that the language ยง0 is not regular.\n"
"\n"
"You will start by proving that the count of ยง1s and ยง2s has to be the same in word if the\n"
"word is an element of the language L as defined above.\n"
"\n"
"Then, you will proceed by proving that the number of ยง3s in a replica of ยง4s corresponds to\n"
"the word's length and the number of ยง5s in such a word is 0.\n"
"\n"
"Following this, you will prove that applying the ยง6 function to any word ยง7 with the ยง8 set to ยง9 and ยง10 corresponds to ยง11\n"
"replicas of the character  ยง12. Using this theorem, you will prove that ยง13 and use this fact in the following proofs.\n"
"\n"
"Next, you will prove how many ยง14s and ยง15s each occur in the words ยง16 and ยง17 with\n"
"ยง18 and statements regarding the length of any word ยง19 and the pumped word.\n"
"\n"
"Thereafter, you will prove that the word ยง20 consists of ยง21 ยง22s\n"
"and ยง23 ยง24s.\n"
"\n"
"Then almost reaching the end, you will prove that the pumped word consists of more ยง25s than\n"
"ยง26s and finally, you will show that the language ยง27 is not regular."
msgstr ""

#. ยง0: ```simp```
#. ยง1: ```exact```
#. ยง2: ```rfl```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "At this point, you can simplify the proof goal by using the induction hypothesis, as\n"
"you would do in any proof by induction for the non-base case. For that, you have two\n"
"possibilities to proceed from this step. You can either proceed by executing the ยง0\n"
"tactic followed by ยง1 tactic combined with the induction hypothesis or you rewrite\n"
"the induction hypothesis and then execute ยง2."
msgstr ""

#. ยง0: ```anBnLang```
#. ยง1: ```a```
#. ยง2: ```b```
#. ยง3: ```anBnLang```
#. ยง4: ```a```
#. ยง5: ```b```
#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
msgid "In this level, you will prove that if any word is an element of the language\n"
"ยง0, then the number of occurrences of the character ยง1 equals the number of\n"
"occurrences of the character ยง2 in that word. This follows from the definition of\n"
"ยง3, where each word is constructed using an equal number of replicas of ยง4\n"
"followed by the same number of replicas of ยง5."
msgstr ""

#. ยง0: ```n โค 0```
#. ยง1: ```n = 0```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "A natural number less than or equal to zero is zero.\n"
"\n"
"If ยง0, then ยง1."
msgstr ""

#. ยง0: ```m```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "You can start with an induction on ยง0, as it is mostly easier to proceed from left to right."
msgstr ""

#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Taking Characters Within the First Word of an Appended Word"
msgstr ""

#. ยง0: ```append```
#. ยง1: ```=```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "As you did in the first proof goal, you can start with rewriting the ยง0\n"
"function. This rewrites the term on the left-hand side of the ยง1 sign into ```cons head\n"
"(tail ++ nil)."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```char```
#. ยง2: ```input_char```
#. ยง3: ```n```
#. ยง4: ```char```
#. ยง5: ```input_char```
#: Game.Levels.CountCharAndElemOf.L05_CharInReplicateChar
msgid "For any character ยง0, if ยง1 appears in a word formed by repeating\n"
"ยง2 exactly ยง3 times, then ยง4 must be equal to ยง5."
msgstr ""

#. ยง0: ```k```
#. ยง1: ```a```
#. ยง2: ```n```
#. ยง3: ```n```
#. ยง4: ```b```
#. ยง5: ```a```
#. ยง6: ```k```
#. ยง7: ```n```
#: Game.Levels.AnBnNotRegular.L04_TakeKAsFromZ
msgid "Very good! You just proved that the first ยง0 characters of the word, formed by\n"
"replicating ยง1 ยง2 times followed by ยง3 replicas of ยง4, are all ยง5s if\n"
"ยง6 is less than ยง7."
msgstr ""

#: Game.Levels.AnBnNotRegular.L04_TakeKAsFromZ
msgid "The First k Characters of a Word z Are All a"
msgstr ""

#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "Take from a Sequence of Repeated Characters"
msgstr ""

#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
msgid "As suggested in the previous level, you can pass all words, natural numbers and the\n"
"hypotheses to the theorem as parameters to avoid repetitive proofs on correctness of all of them.\n"
"This shortens your proof a lot."
msgstr ""

#. ยง0: ```length_replicateChar```
#. ยง1: ```char```
#. ยง2: ```n```
#. ยง3: ```replicateChar```
#. ยง4: ```n```
#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "The theorem ยง0 describes the length of a word created by\n"
"repeating a specific character multiple times. It states that if a character ยง1 is\n"
"repeated ยง2 times using ยง3, the resulting word has length exactly ยง4."
msgstr ""

#: Game.Levels.AnBnNotRegular.L13_CountAInW
msgid "The Suffix w Contains (n - k) as"
msgstr ""

#. ยง0: ```a```
#. ยง1: ```a```
#: Game.Levels.AnBnNotRegular.L02_CountAInReplicateCharA
msgid "In this level, you will prove that if ยง0 occurs at every position of a word, then\n"
"the number of ยง1 in the word is equal to the length of the word."
msgstr ""

#. ยง0: ```k + 1 โค 1 + tail.length```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Bring either the hypothesis ยง0 in the same form as your\n"
"current proof goal, or vice versa."
msgstr ""

#. ยง0: ```elemOf```
#. ยง1: ```A โจ B```
#. ยง2: ```left```
#. ยง3: ```right```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "As you already observed in the previous steps, the ยง0 function returns a clause\n"
"of the form ยง1. For your current proof goal, it means that you can access any of the\n"
"clauses by using the respective tactics ยง2 or ยง3 and observe them individually."
msgstr ""

#. ยง0: ```cases```
#. ยง1: ```word =
#. replicateChar Character.a _ ++ replicateChar Character.b _```
#. ยง2: ```_```
#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
msgid "Next, you can proceed by executing the ยง0 tactic on your hypothesis introduced\n"
"in the previous proof step. This will evaluate all possible values of the term in the hypothesis\n"
"and close the unreachable goals automatically leaving you with a new hypothesis ยง1, where ยง2 represents the\n"
"number of replicas to be created."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```0 + n = n```
#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "Zero is the left identity of addition.\n"
"\n"
"For any natural number ยง0, we have ยง1"
msgstr ""

#. ยง0: ```=```
#. ยง1: ```replicateChar char (k + 1 + n)```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "To reach an equality between the terms on both sides of the ยง0 sign, start by\n"
"transforming ยง1 to an expression which can be easily\n"
"processed further."
msgstr ""

#. ยง0: ```length```
#. ยง1: ```length```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Basically you can memorize, that you start simplifying your expression from the most inner\n"
"term as you can see here. You simplified the concatenation first and now you are gonna simplify\n"
"the terms containing the ยง0 function. For that, you can simplify your current proof\n"
"goal by rewriting the ยง1 function."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```index โค length```
#. ยง2: ```length = 0```
#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "As already discussed earlier, ยง0 is a natural number so it cannot be 0. Thus, it has to\n"
"be 0 when ยง1 and ยง2."
msgstr ""

#. ยง0: ```append```
#. ยง1: ```concat```
#. ยง2: ```replicateChar```
#. ยง3: ```replicateWord```
#. ยง4: ```append```
#. ยง5: ```concat```
#. ยง6: ```replicateChar```
#. ยง7: ```n```
#. ยง8: ```replicateWord```
#. ยง9: ```n```
#. ยง10: ```nil```
#. ยง11: ```append```
#. ยง12: ```concat```
#. ยง13: ```replicateChar```
#. ยง14: ```replicateWord```
#: Game.Levels.AppendAndConcat
msgid "Welcome to **The Append and Concat World**!\n"
"\n"
"In this world, you will investigate the properties of the functions ยง0, ยง1,\n"
"ยง2, and ยง3:\n"
"- The function ยง4 takes two words and produces a new word consisting of the characters\n"
"of the first word followed by the characters of the second word.\n"
"- ยง5 adds a single character to the end of a word.\n"
"- ยง6 produces a new word by replicating a given character ยง7 times.\n"
"- ยง8 produces a new word by appending a given word to itself ยง9 times\n"
"\n"
"The first objective of this world is to establish that appending the empty word ยง10\n"
"to any word leaves that word unchanged.\n"
"\n"
"Next, you will analyze how the length of a word behaves under ยง11 and ยง12.\n"
"\n"
"Finally, building upon these lemmas, you will prove the lengths of words formed using the functions\n"
"ยง13 and ยง14.\n"
"\n"
"Let's get started!"
msgstr ""

#. ยง0: ```z```
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```h_word```
#. ยง3: ```z```
#. ยง4: ```z_in_lang```
#. ยง5: ```length_z```
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid "Now, you decompose your word ยง0 as ยง1, by first introducing an\n"
"auxiliary statement that feeds ยง2 with the word ยง3 you chose and the properties\n"
"ยง4 and ยง5. Then you can split the newly introduced logical statement into\n"
"individual statements/hypotheses and proceed with the proof."
msgstr ""

#. ยง0: ```b```
#. ยง1: ```v```
#: Game.Levels.AnBnNotRegular.L08_CountAInV
msgid "Very good! Next, you will show, how man ยง0s occur in the word ยง1."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```char_count```
#. ยง2: ```n```
#. ยง3: ```char_count```
#. ยง4: ```replicateChar char n```
#. ยง5: ```n```
#. ยง6: ```0```
#: Game.Levels.CountCharAndElemOf.L02_CountCharInReplicateChar
msgid "For characters ยง0 and ยง1 and a natural number ยง2,\n"
"counting occurrences of ยง3 in ยง4\n"
"returns ยง5 if the two characters are equal, and ยง6 otherwise."
msgstr ""

#. ยง0: ```h```
#. ยง1: ```intros```
#: Game.Levels.AnBnNotRegular.L02_CountAInReplicateCharA
msgid "If you carefully look at your current proof goal, it looks a lot like the hypothesis\n"
"ยง0. In order to prove its correctness, simplify your current proof goal using ยง1\n"
"tactic."
msgstr ""

#. ยง0: ```intros h```
#. ยง1: ```->```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "You can split the implication in the current expression by executing ยง0. This\n"
"creates an induction hypothesis using the term on the left-hand side of the ยง1 sign and\n"
"creates a proof goal out of the term on the right-hand side."
msgstr ""

#. ยง0: ```rewrite```
#. ยง1: ```nil ++ nil = nil```
#. ยง2: ```rewrite [append]```
#. ยง3: ```nil```
#. ยง4: ```nil```
#. ยง5: ```nil = nil```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "So far, you have seen how an expression can be simplified using the ยง0 tactic\n"
"and a theorem if you have played the Natural Number Game. Now, you will see that you can\n"
"combine this tactic also with function definitions: You can simplify your current proof state\n"
"ยง1 by executing the tactic ยง2, as it corresponds to\n"
"appending an empty word ยง3 with another empty word ยง4. The result is then the\n"
"equation ยง5."
msgstr ""

#. ยง0: ```h```
#. ยง1: ```A โจ B```
#. ยง2: ```elemOf```
#. ยง3: ```cases```
#. ยง4: ```h```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "If you now observe ยง0, you see that it is a clause of the form ยง1. So, to\n"
"prove the statement for all possible return values of ยง2, you can proceed with\n"
"executing the ยง3 tactic with the hypothesis ยง4."
msgstr ""

#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "Very good! You just proved that appending words preserves all characters from both words.\n"
"Thus, the total length of the resulting word is the sum of the length of the first and the second word.\n"
"From now onwards, you can rewrite both terms to one another whenever necessary."
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```index```
#. ยง2: ```word_1 ++ word_2```
#. ยง3: ```index```
#. ยง4: ```word_1```
#. ยง5: ```word_2```
#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "If the number of characters to be dropped does not exceed the length of ยง0,\n"
"then dropping ยง1 characters from ยง2 is the same as\n"
"dropping ยง3 characters from ยง4 and then appending ยง5."
msgstr ""

#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "Dropping Characters Within the First Word of an Appended Word"
msgstr ""

#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid ""
msgstr ""

#. ยง0: ```count_char_in_append```
#: Game.Levels.CountCharAndElemOf.L01_CountCharInAppend
msgid "The following statement ยง0 proves that the number of times a\n"
"character appears in the appended word is exactly the sum of its occurrences in each of the original\n"
"words."
msgstr ""

#. ยง0: ```simp [take]```
#. ยง1: ```simp```
#. ยง2: ```simp```
#. ยง3: ```take```
#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid "In order to solve the current goal, the easiest way to proceed is to execute\n"
"ยง0. As described earlier, the ยง1 tactic simplifies your current proof\n"
"goal using all function definitions and theorems that are curently available and have been\n"
"notated with the ยง2 keyword. In this case, it additionally uses the ยง3 function\n"
"to simplify the current proof goal further."
msgstr ""

#. ยง0: $L = {a^n b^n | n โฅ 0}$
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid "This theorem states that the language ยง0 is not regular."
msgstr ""

#: Game.Levels.AppendAndConcat
msgid "Append and Concat"
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```word_2```
#. ยง2: ```word_1 ++ word_2```
#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "For any words ยง0 and ยง1, the length of their append\n"
"ยง2 is the sum of their lengths."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```length```
#. ยง2: ```index```
#. ยง3: ```index โค length```
#. ยง4: ```index```
#. ยง5: ```replicateChar char length```
#. ยง6: ```length - index```
#. ยง7: ```char```
#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "For a character ยง0 and natural numbers ยง1 and ยง2 such that\n"
"ยง3, dropping ยง4 characters from ยง5\n"
"produces a word consisting of ยง6 replicas of ยง7."
msgstr ""

#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "Very good! Let's move forward to the next level where you will show how how the length\n"
"of a word changes when it is repeated multiple times."
msgstr ""

#. ยง0: ```m```
#. ยง1: ```n```
#. ยง2: ```k```
#. ยง3: ```k```
#. ยง4: ```m```
#. ยง5: ```n```
#. ยง6: ```(m + k) - (n + k) = m - n```
#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "Cancel a common addend in a subtraction.\n"
"\n"
"For any natural numbers ยง0, ยง1, and ยง2, adding the same number ยง3 to\n"
"both ยง4 and ยง5 does not change their difference:\n"
"ยง6."
msgstr ""

#. ยง0: $L = {a^n b^n | n
#. โฅ 0}$
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid "In this final level of the game, you will prove that the language ยง0 is not regular."
msgstr ""

#: Game.Levels.AnBnNotRegular.L10_LengthZEq2n
msgid "Well done! Next, you'll show how the length of the pumped word is calculated."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```zero```
#. ยง2: ```replicateChar```
#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "You first prove the statement for the case, where ยง0 has the value ยง1 and\n"
"you start by rewriting the ยง2 function."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n * 0 = 0```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Zero is an absorbing element for multiplication.\n"
"\n"
"For any natural number ยง0, we have ยง1."
msgstr ""

#: Game.Levels.AnBnNotRegular.L10_LengthZEq2n
msgid "To proceed from here, you are given a theorem stating that adding a number\n"
"to itself is equal to multiplying the same number by 2. Use that!"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: ```n```
#. ยง1: ```b```
#. ยง2: ```n```
#. ยง3: ```a```
#. ยง4: ```2 * n```
#. ยง5: ```n```
#: Game.Levels.AnBnNotRegular.L10_LengthZEq2n
msgid "In this proof, you will show that appending ยง0 replicas of ยง1 to ยง2\n"
"replicas of ยง3 means that the word has a length equal to ยง4 since each individual word\n"
"has the length ยง5."
msgstr ""

#: Game.Levels.AppendAndConcat.L04_LengthReplicateChar
msgid "Length of Character Replicas"
msgstr ""

#. ยง0: ```v```
#. ยง1: ```a```
#. ยง2: ```v```
#: Game.Levels.AnBnNotRegular.L07_CountBInU
msgid "Very good! In the next level, you will show that ยง0 consists of as many ยง1s as\n"
"the length of ยง2 is."
msgstr ""

#. ยง0: ```word```
#. ยง1: ```char```
#. ยง2: ```length (concat word char) = length word + 1```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "For any ยง0 and character ยง1, ยง2.\n"
"This reflects the fact that concatenating a character to a word increases its length by one."
msgstr ""

#. ยง0: ```replicateChar input_char n```
#. ยง1: ```input_char```
#: Game.Levels.CountCharAndElemOf.L05_CharInReplicateChar
msgid "In this level, you will show that if any character appears in a word formed by\n"
"ยง0, then that character and ยง1 must be equal.\n"
"\n"
"In other words, you will prove that a word made of repeating a specifif character cannot\n"
"contain any other character."
msgstr ""

#. ยง0: ```w```
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```n - k```
#. ยง3: ```a```
#: Game.Levels.AnBnNotRegular.L13_CountAInW
msgid "Using the theorem proved in the previous level, you will show that the suffix ยง0\n"
"of ยง1 contains ยง2 ยง3s."
msgstr ""

#. ยง0: ```w```
#. ยง1: ```n```
#. ยง2: ```b```
#: Game.Levels.AnBnNotRegular.L13_CountAInW
msgid "Very good! Next, you will prove that ยง0 contains exactly ยง1 ยง2s."
msgstr ""

#. ยง0: ```anBnLang```
#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
msgid "Well done! You just proved the first theorem, which is part of the final proof for the\n"
"fact that ยง0 is not regular. Let's move on to the next proof."
msgstr ""

#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
msgid "Any Prefix of Length at Most n in a Word z Is All a"
msgstr ""

#. ยง0: $z = a^n b^n$
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```k = length u + length v```
#. ยง3: ```k โค n```
#. ยง4: ```length u < k```
#. ยง5: ```w```
#. ยง6: ```n - k```
#. ยง7: ```a```
#: Game.Levels.AnBnNotRegular.L13_CountAInW
#: Game.Levels.AnBnNotRegular.L14_CountBInW
msgid "For a word ยง0, which is decomposed as ยง1 with\n"
"ยง2, ยง3 and ยง4, the remaining\n"
"suffix ยง5contains exactly ยง6 replicas of ยง7."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```word_1```
#. ยง2: ```index```
#. ยง3: ```word_1 ++ word_2```
#. ยง4: ```word_1```
#. ยง5: ```word_2```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "If ยง0 is greater than the length of ยง1, then taking ยง2\n"
"characters from ยง3 returns all of ยง4 followed by the\n"
"remaining characters taken from ยง5."
msgstr ""

#: Game
msgid "The Pumping Lemma Game"
msgstr ""

#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
msgid "Try to remember, which of the theorems proven in the previous worlds is appropriate to\n"
"proceed with the current proof goal."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```word_1```
#. ยง2: ```index```
#. ยง3: ```word_1 ++ word_2```
#. ยง4: ```index - length word_1```
#. ยง5: ```word_2```
#: Game.Levels.TakeAndDrop.L06_DropAppendRight
msgid "In this level, you will prove that if ยง0 is greater than the length\n"
"of ยง1, then dropping ยง2 characters from ยง3 is\n"
"equivalent to dropping ยง4 characters from ยง5 alone."
msgstr ""

#. ยง0: ```word```
#. ยง1: ```word ++ nil = word```
#. ยง2: ```nil```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "For any ยง0, ยง1. Appending the empty word ยง2 to any word\n"
"results in the word itself.\n"
"\n"
"This reflects the identity property of the empty word when appending words to one another."
msgstr ""

#. ยง0: ```a```
#. ยง1: ```a```
#. ยง2: ```b```
#: Game.Levels.AnBnNotRegular.L03_CountBInReplicateCharA
msgid "Well done! With the previous statement and the one in this level you proved that, if a\n"
"word consists of only ยง0s then the count ยง1s in that word is equal to the length of that\n"
"word, which also results in the count ยง2 being 0 in that word."
msgstr ""

#. ยง0: ```a```
#. ยง1: ```b```
#. ยง2: ```w```
#. ยง3: ```z```
#: Game.Levels.AnBnNotRegular.L12_WEqRemainingAsNBs
msgid "Using this theorem, will prove separately how many ยง0s and ยง1s occur in the\n"
"suffix ยง2 of ยง3."
msgstr ""

#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "Appending Two Replicas of a Single Character Adds Their Counts"
msgstr ""

#: Game.Levels.CountCharAndElemOf.L05_CharInReplicateChar
msgid "All Characters in a Word Formed By Replicating a Characters are Same"
msgstr ""

#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Prepending a Character Increases Word Length by One"
msgstr ""

#. ยง0: ```split```
#. ยง1: ```char = char_count```
#. ยง2: ```char โ char_count```
#: Game.Levels.CountCharAndElemOf.L02_CountCharInReplicateChar
msgid "You can ยง0 your current proof goal at this point. Then, you will prove the outcome\n"
"for the two cases ยง1 and ยง2."
msgstr ""

#. ยง0: ```simp```
#. ยง1: ```h```
#: Game.Levels.AnBnNotRegular.L02_CountAInReplicateCharA
msgid "If you do not know how to proceed from here, try using the ยง0\n"
"tactic. It will simplify your expression using all theorems that are available and applicable to\n"
"your current proof goal along with the hypothesis ยง1."
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```word_2```
#. ยง2: ```word_2```
#. ยง3: ```index โฅ length word_1```
#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "Very good! You just proved that dropping characters in ยง0 and then\n"
"appending ยง1 leaves ยง2 unaffected. Let's move on to proving the corresponding\n"
"theorems for take and drop for ยง3."
msgstr ""

#: Game
msgid "A playful way to learn about the Pumping Lemma"
msgstr ""

#. ยง0: ```m```
#. ยง1: ```n```
#. ยง2: ```m โค m + n```
#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "Any natural number is less than or equal to itself plus another natural number.\n"
"\n"
"For natural numbers ยง0 and ยง1, it asserts: ยง2"
msgstr ""

#. ยง0: ```simp```
#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "You can also use the ยง0 tactic to solve the current proof goal in one single step\n"
"instead of solving it in multiple steps."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L04_CharInAppendRight
msgid "Very good! Now, let's proceed towards the last proof of this world!"
msgstr ""

#. ยง0: ```index```
#. ยง1: ```word_1```
#. ยง2: ```index```
#. ยง3: ```word_1 ++ word_2```
#. ยง4: ```index - length
#. word_1```
#. ยง5: ```word_2```
#: Game.Levels.TakeAndDrop.L06_DropAppendRight
msgid "If ยง0 is greater than the length of ยง1, then dropping ยง2\n"
"characters from ยง3 is the same as dropping ยง4 characters from ยง5."
msgstr ""

#. ยง0: ```countCharInWord```
#. ยง1: ```elemOf```
#. ยง2: ```append```
#. ยง3: ```replicateChar```
#. ยง4: ```countCharInWord```
#. ยง5: ```elemOf```
#. ยง6: ```elemOf char word```
#. ยง7: ```char โw word```
#: Game.Levels.CountCharAndElemOf
msgid "Welcome to **The CountChar and ElemOf World**!\n"
"\n"
"In this world, you will study the behavior of the functions ยง0 and ยง1\n"
"in combination with the functions ยง2 and ยง3:\n"
"- ยง4 returns the number of occurrences of a given character in a word.\n"
"- ยง5 determines whether a character is in a word or not. ยง6 can\n"
"also be written as ยง7 and the property holds if and only if the given character\n"
"appears in that word at least once.\n"
"\n"
"You will first prove that counting the occurrences of a character in word generated by the append\n"
"function preserves the counts from individual words and sums them up.\n"
"You will then analyze how character counting behaves in words formed by repeating a single character.\n"
"\n"
"Following this, you will establish that character membership is preserved under appending, both when a\n"
"character appears in the left word and when it appears in the right word.\n"
"Finally, you will prove that character membership is also preserved for character replicas.\n"
"\n"
"Let's get started!"
msgstr ""

#. ยง0: $z = a^n b^n$
#. ยง1: ```z =
#. (u ++ v) ++ w```
#. ยง2: ```k = length u + length v```
#. ยง3: ```k โค n```
#. ยง4: ```length u < k```
#. ยง5: ```w```
#. ยง6: ```n - k```
#. ยง7: ```a```
#. ยง8: ```n```
#. ยง9: ```b```
#: Game.Levels.AnBnNotRegular.L12_WEqRemainingAsNBs
msgid "In this proof, you will show that decomposing a word ยง0 as  ยง1 with ยง2, ยง3 and ยง4, the\n"
"suffix ยง5consists of exactly ยง6 replicas of ยง7 followed by ยง8 replicas\n"
"of ยง9."
msgstr ""

#. ยง0: ```a```
#. ยง1: ```b```
#. ยง2: ```n```
#. ยง3: ```k```
#. ยง4: ```k โค n```
#. ยง5: ```n```
#. ยง6: ```b```
#. ยง7: ```n```
#. ยง8: ```a```
#. ยง9: ```k```
#. ยง10: ```k```
#. ยง11: ```a```
#: Game.Levels.AnBnNotRegular.L04_TakeKAsFromZ
msgid "For two characters ยง0 and ยง1 and two natural number ยง2 and ยง3\n"
"with ยง4, if a word consists of ยง5 replicas of ยง6 appended to\n"
"ยง7 replicas of ยง8, then taking ยง9 characters from that word results\n"
"in ยง10 replicas of ยง11."
msgstr ""

#. ยง0: ```word_1```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "You should start with induction over ยง0 in this proof."
msgstr ""

#. ยง0: ```a```
#. ยง1: ```b```
#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
msgid "In this level, you will prove that the pumped word contains more ยง0s than it\n"
"contains ยง1s."
msgstr ""

#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "Well done! You just showed that when taking more characters than are present in the\n"
"first word, the result includes the entire first word plus the corresponding number of characters\n"
"from the second word. Let's move on to the last proof in the second world."
msgstr ""

#. ยง0: ```take```
#. ยง1: ```drop```
#. ยง2: ```take```
#. ยง3: ```drop```
#. ยง4: ```take```
#. ยง5: ```nil```
#. ยง6: ```take```
#. ยง7: ```drop```
#. ยง8: ```word_1```
#. ยง9: ```word_1 ++ word_2```
#. ยง10: ```word_1```
#. ยง11: ```word_2```
#. ยง12: ```word_1
#. ++ word_2```
#. ยง13: ```word_1```
#. ยง14: ```word_2```
#. ยง15: ```word_1
#. ++ word_2```
#. ยง16: ```word_2```
#. ยง17: ```word_1 ++ word_2```
#. ยง18: ```take```
#. ยง19: ```drop```
#. ยง20: ```replicateChar```
#: Game.Levels.TakeAndDrop
msgid "Welcome to the second world of this game: **The Take and Drop World**!\n"
"\n"
"Here, you will study the behavior of the functions ยง0 and ยง1 on words and their\n"
"interaction with word appending.\n"
"\n"
"The ยง2 function returns a prefix of a given word consisting of the character upto the\n"
"specified index, while the ยง3 function returns a suffix of a given word consisting of the\n"
"characters starting at the given index.\n"
"\n"
"You will start by proving, that the function ยง4 returns the word itself when the index\n"
"corresponds to the length of the given word. At the same time, with the same value for the index,\n"
"the drop function returns the empty word ยง5.\n"
"\n"
"Following this, you will analyze how ยง6 and ยง7 behave when combined with the append\n"
"function:\n"
"- The prefix to be returned of a given word lies in ยง8 for ยง9.\n"
"- The suffix to be returned of a given word lies in both ยง10 and ยง11 for ยง12.\n"
"- The prefix to be returned of a given word lies in both ยง13 and ยง14 for ยง15.\n"
"- The suffix to be returned of a given word lies in ยง16 for  ยง17.\n"
"\n"
"Lastly, you will analyze how ยง18 and ยง19 behave when combined with the function\n"
"ยง20.\n"
"\n"
"Let's start!"
msgstr ""

#: Game
msgid "Welcome to the Pumping Lemma Game!\n"
"\n"
"In this game, we build a definition of a language in terms of formal languages. For this language,\n"
"we prove various facts about appending two words or concating a character to a word, etc.\n"
"These lemmas are then used to build the Pumping Lemma for regular languages.\n"
"Finally, this Pumping Lemma is applied to some languages to show that those languages are not regular.\n"
"\n"
"This game should help you to dig deep into the definition of the Pumping Lemma. It should help you\n"
"to understand the Pumping Lemma better by deriving several facts you might not think of when writing\n"
"the proof on paper.\n"
"\n"
"Good luck and enjoy learning about the Pumping Lemma!"
msgstr ""

#. ยง0: ```w```
#: Game.Levels.AnBnNotRegular.L13_CountAInW
msgid "In order to execute the tactic correctly, you have to pass the word ยง0 to that theorem\n"
"as you did in one of the recent proofs and to avoid repetitive proofs for any other words, numbers\n"
"or the hypotheses that theorem requires, you can pass those to the theorem as well. That makes\n"
"your proof half as long."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```replicateChar char length```
#. ยง2: ```index```
#. ยง3: ```length```
#. ยง4: ```length - index```
#. ยง5: ```char```
#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "In this level, you will prove that if you drop ยง0 characters from\n"
"ยง1, where ยง2 does not exceed ยง3, the resulting\n"
"word consists of exactly ยง4 replicas of the character ยง5."
msgstr ""

#. ยง0: ```a```
#. ยง1: ```z```
#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "Very good! You will use this theorem later on to show that the pumped word contains more\n"
"ยง0s than the non pumped word ยง1."
msgstr ""

#. ยง0: ```word
#. = left ++ right```
#. ยง1: ```take```
#. ยง2: ```word```
#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
msgid "To prove this statement, start by deriving the fact that left can be retrieved from ยง0 by applying the ยง1 function to ยง2."
msgstr ""

#. ยง0: ```a```
#. ยง1: ```b```
#. ยง2: ```n```
#. ยง3: ```k```
#. ยง4: ```k โค n```
#. ยง5: ```n```
#. ยง6: ```a```
#. ยง7: ```n```
#. ยง8: ```b```
#. ยง9: ```k```
#. ยง10: ```k```
#. ยง11: ```a```
#: Game.Levels.AnBnNotRegular.L04_TakeKAsFromZ
msgid "In the following, you will show that for two characters ยง0 and ยง1 and two\n"
"natural numbers ยง2 and ยง3, if ยง4 and a word consists of ยง5 replicas of\n"
"ยง6 followed by ยง7 replicas of ยง8, then taking ยง9 characters from that word\n"
"results in ยง10 replicas of ยง11."
msgstr ""

#. ยง0: ```intro```
#. ยง1: ```->```
#. ยง2: ```->```
#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
msgid "You can start by splitting the implication in your current proof using the ยง0\n"
"tactic. By doing this, you will obtain a hypothesis which corresponds to the term on the\n"
"left-hand side of the ยง1 sign and your proof goal will correspond to the term on the\n"
"right-hand side of the ยง2 sign."
msgstr ""

#. ยง0: ```a```
#. ยง1: ```a```
#: Game.Levels.AnBnNotRegular.L02_CountAInReplicateCharA
#: Game.Levels.AnBnNotRegular.L03_CountBInReplicateCharA
msgid "If every character occurring in a word is ยง0, then the number of ยง1s in the\n"
"word is equal to the length of the word."
msgstr ""

#. ยง0: ```char```
#. ยง1: ```m```
#. ยง2: ```n```
#. ยง3: ```replicateChar char n```
#. ยง4: ```replicateChar char m```
#. ยง5: ```replicateChar char (m + n)```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "For a character ยง0 and natural numbers ยง1 and ยง2, appending\n"
"ยง3 to ยง4 produces a word\n"
"equivalent to ยง5."
msgstr ""

#. ยง0: ```pumpingProperty anBnLang```
#. ยง1: ```False```
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid "You start by splitting your proof goal into the hypothesis ยง0\n"
"and a proof goal ยง1. This is analogue to specifying 'proof by contradiction' in a\n"
"pen-and-paper proof."
msgstr ""

#. ยง0: ```nil :: char```
#. ยง1: ```nil```
#. ยง2: ```concat nil char```
#. ยง3: ```rewrite [concat]```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "The term ยง0 in your current proof goal corresponds to concatenating a given\n"
"character to the empty word ยง1, this is a notation for writing ยง2 in\n"
"user friendly way. So, you can simplify this expression by executing ยง3."
msgstr ""

#. ยง0: ```rfl```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "In order to prove this proof goal, you can execute the ยง0 tactic."
msgstr ""

#. ยง0: ```m```
#. ยง1: ```n```
#. ยง2: ```n โค m```
#. ยง3: ```(m + n) - n = m```
#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "Adding a natural number and then subtracting the same number results in\n"
"the original number.\n"
"\n"
"For natural numbers ยง0 and ยง1 with ยง2, it asserts:\n"
"ยง3"
msgstr ""

#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid "In this level, you will prove that taking a number of characters equal to the\n"
"length of a word returns the word itself."
msgstr ""

#: Game.Levels.AnBnNotRegular.L12_WEqRemainingAsNBs
msgid "The Suffix w Contains All Remaining as And All bs"
msgstr ""

#. ยง0: ```w```
#. ยง1: ```z```
#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "If you do not know, how to proceed from here, you can start by writing an auxiliary thoerem,\n"
"that retrieves the length of the word ยง0 using the length of the word ยง1."
msgstr ""

#. ยง0: ```z = $a^n b^n$```
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```u ++ v```
#. ยง3: ```n```
#. ยง4: ```u```
#. ยง5: ```a```
#. ยง6: ```b```
#. ยง7: ```u```
#: Game.Levels.AnBnNotRegular.L07_CountBInU
#: Game.Levels.AnBnNotRegular.L09_CountBInV
msgid "If a word ยง0 is decomposed as ยง1 and the length of ยง2\n"
"is at most ยง3, then  ยง4 consists only of ยง5s. That means, the the number of occurrences\n"
"of ยง6 in ยง7 is equal to 0."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```word_1```
#. ยง2: ```index```
#. ยง3: ```word_1 ++ word_2```
#. ยง4: ```index```
#. ยง5: ```word_1```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "In this level, you will prove that if the number of characters ยง0 to take\n"
"does not exceed the length of ยง1, then taking ยง2 characters from\n"
"ยง3 is equivalent to taking ยง4 characters from ยง5 alone."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```m```
#. ยง2: ```k```
#. ยง3: ```(n + m) + k = n + (m + k)```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Addition is associative.\n"
"\n"
"For all natural numbers ยง0, ยง1, and ยง2, we have ยง3."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```a```
#. ยง2: ```n```
#. ยง3: ```b```
#. ยง4: ```left ++
#. right```
#. ยง5: ```left```
#. ยง6: ```n```
#. ยง7: ```left```
#. ยง8: ```a```
#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
msgid "In this level, you will prove that if a word consists of ยง0 replicas of\n"
"ยง1 followed by ยง2 replicas of ยง3, and that word is written as ยง4 where the length of ยง5 is at most ยง6, then ยง7 must consist\n"
"only of ยง8s."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```Nat.succ n```
#. ยง2: ```n + 1```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "The successor of a natural number is adding one.\n"
"\n"
"For any natural number ยง0, ยง1 is equal to ยง2."
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```word_1```
#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "In this level, you start with an induction on ยง0 so that you can easily prove the\n"
"statement for all possible values of ยง1."
msgstr ""

#. ยง0: ```have```
#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
msgid "To derive this fact, you can write a helper theorem using the ยง0 tactic."
msgstr ""

#. ยง0: ```m```
#. ยง1: ```n```
#. ยง2: ```n โค m```
#. ยง3: ```(n + m) - n = m```
#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "Adding a natural number and then substracting the same number results in\n"
"the original number.\n"
"\n"
"For natural number ยง0 and ยง1 with ยง2, it asserts:\n"
"ยง3"
msgstr ""

#: Game.Levels.AnBnNotRegular.L14_CountBInW
msgid "Well done! You are almost there, one more level to go to the final proof!"
msgstr ""

#. ยง0: $L = {a^n b^n | n โฅ 0}$
#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid "Well done! You did it! You proved that the language ยง0 is not\n"
"regular. By, now you should have understood how exactly the pumping lemma is built and how to use it\n"
"to prove that a language is not regular."
msgstr ""

#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
msgid "The Number of as is Equal to the Number of bs in anBnLang"
msgstr ""

#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "You just proved that the second word does not influence the result when taking a\n"
"number of characters within the bounds of the first word. Well done! Let's move to the level 4!"
msgstr ""

#. ยง0: ```Show more help!```
#: Game.Levels.AppendAndConcat.L01_AppendNil
msgid "If you do not know how to proceed, click on the ยง0 button!"
msgstr ""

#. ยง0: ```a```
#. ยง1: ```b```
#: Game.Levels.AnBnNotRegular.L03_CountBInReplicateCharA
msgid "In the level, you will prove that if ยง0 occurs at every position of a word, then\n"
"the number of ยง1 in the word is equal to 0."
msgstr ""

#. ยง0: ```drop_all```
#. ยง1: ```nil```
#: Game.Levels.TakeAndDrop.L02_DropAll
msgid "In this level, you will prove the theorem ยง0. It states that dropping\n"
"a number of characters equal to the length of a word results in the empty word ยง1."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L02_CountCharInReplicateChar
msgid "Count Occurrences of a Character in Word Formed by a Character's Replicas"
msgstr ""

#: Game.Levels.AppendAndConcat.L03_LengthAppend
msgid "Length of a Word Appended to Another Word"
msgstr ""

#. ยง0: ```Take and Drop```
#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "With this, you have successfully proven all the goals of the ยง0\n"
"World. You are getting closer to executing the pumping lemma on concrete languages. Let's move\n"
"on to the third world!"
msgstr ""

#: Game.Levels.AnBnNotRegular.L02_CountAInReplicateCharA
msgid "In a Word Formed by Only a, Counting a Returns the Wordโs Length"
msgstr ""

#. ยง0: ```Nat.succ a โค Nat.succ b```
#. ยง1: ```a โค b```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "Cancel successors from both sides of an inequality.\n"
"\n"
"If ยง0, then ยง1."
msgstr ""

#: Game
msgid "In this game, you prove some facts about the Language structure specifically defined\n"
"for this game and later on other facts about the Pumping Lemma. Finally, you use these lemmas to\n"
"prove that the provided examples fo languages are not regular languages."
msgstr ""

#: Game.Levels.AnBnNotRegular.L03_CountBInReplicateCharA
msgid "In a Word Formed by Only a, Counting b Returns 0"
msgstr ""

#. ยง0: ```n```
#. ยง1: ```m```
#. ยง2: ```n```
#. ยง3: ```Nat.succ m```
#. ยง4: ```n```
#. ยง5: ```n * m```
#: Game.Levels.AppendAndConcat.L05_LengthReplicateWord
msgid "Multiplication by a successor.\n"
"\n"
"For any natural numbers ยง0 and ยง1, multiplying ยง2 by ยง3\n"
"is equal to adding ยง4 to ยง5."
msgstr ""

#. ยง0: ```word```
#. ยง1: ```length word```
#: Game.Levels.TakeAndDrop.L01_TakeAll
msgid "For any word ยง0, taking ยง1 characters returns the original word."
msgstr ""

#. ยง0: ```countCharInWord```
#. ยง1: ```append```
#. ยง2: ```countCharInWord```
#. ยง3: ```replicateChar```
#: Game.Levels.CountCharAndElemOf.L01_CountCharInAppend
msgid "Very good! You just how ยง0 behaves in combination with the ยง1\n"
"function. Now, let's move over to showing the behavior of ยง2 in combination with\n"
"ยง3."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```replicateChar char length```
#. ยง2: ```index```
#. ยง3: ```length```
#. ยง4: ```index```
#. ยง5: ```char```
#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "In this level, you will prove that if you take ยง0 characters from\n"
"ยง1, where ยง2 does not exceed ยง3, the resulting\n"
"word consists of exactly ยง4 replicas of the character ยง5."
msgstr ""

#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
msgid "From here, the proof should be easy to solve using the theorems you have proven so far."
msgstr ""

#: Game.Levels.AnBnNotRegular.L04_TakeKAsFromZ
msgid "Considering that you proved all theorems used in this proof in earlier worlds, this proof\n"
"should be trivial."
msgstr ""

#. ยง0: ```m```
#. ยง1: ```n```
#. ยง2: ```m```
#. ยง3: ```n```
#. ยง4: ```m + 1 โค n```
#: Game.Levels.AnBnNotRegular.L15_MoreAsThanBs
msgid "Deduce a strict inequality from a successor-based inequality.\n"
"\n"
"For natural numbers ยง0 and ยง1, it states that if the successor of\n"
"ยง2 is less than or equal to ยง3: ยง4."
msgstr ""

#: Game.Levels.AnBnNotRegular.L14_CountBInW
msgid "The Suffix w Contains n bs"
msgstr ""

#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Well done! You just demonstrated that extending a word by one character results in\n"
"a word whose length is precisely one greater than before. Let's move on to the next proof!"
msgstr ""

#. ยง0: ```h```
#. ยง1: ```h```
#: Game.Levels.TakeAndDrop.L07_TakeReplicateChar
msgid "As you can see, your current proof goal and the hypothesis ยง0 represent a very\n"
"similar fact. You can now either transform ยง1 such that it is equal to the current proof\n"
"goal or vice versa."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```m```
#. ยง2: ```m + n```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "In this level, you will show that if you append a word consisting of ยง0 replicas\n"
"of a character to a word consisting ยง1 replicas of the same character, then the resulting word\n"
"corresponds to ยง2 replicas of that character."
msgstr ""

#: Game.Levels.CountCharAndElemOf.L02_CountCharInReplicateChar
msgid "In the following, you will prove that the number of occurrences of a character\n"
"in a word formed by a character's replicas only depends on whether the character being counted\n"
"matches the replicated one. If the characters match, the count equals the number of repetitions;\n"
"otherwise, it is zero."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#. ยง0: ```โจ```
#. ยง1: ```right```
#: Game.Levels.CountCharAndElemOf.L04_CharInAppendRight
msgid "As you can observe in your current proof goal, the term on the right-hand side of the\n"
"ยง0 matches your induction hypothesis. So, you can retrieve it by using the keyword\n"
"ยง1 and then proceed with the proof."
msgstr ""

#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
msgid "Finally, you can simplify the current proof goal and complete the first proof in this\n"
"world."
msgstr ""

#. ยง0: ```intros```
#: Game.Levels.AnBnNotRegular.L06_CountAInU
msgid "As you did earlier, you can split this implication into an hypothesis and proof goal using\n"
"the ยง0 tactic."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n```
#. ยง2: ```2```
#. ยง3: ```n```
#. ยง4: `2 * n = n + n`
#: Game.Levels.AnBnNotRegular.L10_LengthZEq2n
msgid "Multiplication by two is addition with itself.\n"
"\n"
"For any natural number ยง0, multiplying ยง1 by ยง2 is\n"
"equal to adding ยง3 to itself, i.e. ยง4."
msgstr ""

#. ยง0: ```w```
#. ยง1: ```=```
#. ยง2: ```w```
#. ยง3: ```z```
#: Game.Levels.AnBnNotRegular.L12_WEqRemainingAsNBs
msgid "To retrieve an equality between the ยง0 and the term on the right-hand side of the\n"
"ยง1 sign, you could start by introducing an auxiliary theorem, which states how the word\n"
"ยง2 can be retrieved from the word ยง3. After that, the procedure is trivial."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```a```
#. ยง2: ```n```
#. ยง3: ```b```
#. ยง4: `left ++ right`
#. ยง5: ```left```
#. ยง6: ```n```
#. ยง7: ```left```
#. ยง8: ```a```
#: Game.Levels.AnBnNotRegular.L05_LeftEqReplicateCharA
msgid "This lemma states that if a word consists of ยง0 replicas of ยง1 followed\n"
"by ยง2 replicas of ยง3, and that word is written as ยง4 where\n"
"the length of ยง5 is at most ยง6, then ยง7 must consist only of\n"
"ยง8s."
msgstr ""

#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "Taking Characters Beyond the First Word in an Appended Word"
msgstr ""

#. ยง0: ```word_1```
#. ยง1: ```word_2```
#. ยง2: ```index```
#. ยง3: ```word_2```
#. ยง4: ```index```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "At this point, you are observing the non empty case of ยง0 and your proof goal\n"
"right now has two more values of an inductive type: ยง1 and ยง2. However, you\n"
"do not need to observe ยง3 as you want to transform the left-hand side term such that\n"
"word_2 does not occur in it anymore. So you proceed by observing all possible values of\n"
"ยง4."
msgstr ""

#: Game.Levels.TakeAndDrop.L06_DropAppendRight
msgid "Dropping Characters Beyond the First Word in an Appended Word"
msgstr ""

#: Game.Levels.AnBnNotRegular.L16_AnBnNotRegular
msgid "AnBnLang is Not Regular"
msgstr ""

#. ยง0: ```m```
#. ยง1: ```n```
#. ยง2: ```k```
#. ยง3: ```n โค m```
#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "States an associativity property involving addition and subtraction\n"
"for natural numbers.\n"
"\n"
"For natural numbers ยง0, ยง1, and ยง2 with ยง3, it\n"
"states that: m - n + k = m + k - n"
msgstr ""

#. ยง0: ```index```
#. ยง1: ```word_1```
#. ยง2: ```index```
#. ยง3: ```word_1 ++ word_2```
#. ยง4: ```index```
#. ยง5: ```word_1```
#. ยง6: ```word_2```
#: Game.Levels.TakeAndDrop.L04_DropAppendLeft
msgid "In this level, you will prove that if the number of characters to drop ยง0\n"
"does not exceed the length of the first word ยง1, then dropping ยง2 characters\n"
"from ยง3 is equivalent to dropping ยง4 characters from ยง5\n"
"and then appending the second word ยง6."
msgstr ""

#. ยง0: ```replicateChar```
#: Game.Levels.AppendAndConcat.L06_AppendReplicateChar
msgid "Now, you can rewrite the term on the right using ยง0."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```m```
#. ยง2: ```n + m = n + m```
#: Game.Levels.AppendAndConcat.L02_LengthConcat
msgid "Addition is commutative.\n"
"\n"
"For all natural numbers ยง0 and ยง1, we have ยง2."
msgstr ""

#. ยง0: ```index```
#. ยง1: ```induction```
#. ยง2: ```cases```
#. ยง3: ```induction```
#. ยง4: ```cases```
#: Game.Levels.TakeAndDrop.L03_TakeAppendLeft
msgid "To observe all possible values of ยง0, you can either proceed\n"
"with ยง1 or with the ยง2 tactic. In comparison with ยง3,\n"
"ยง4 does not produce any (induction) hypothesis."
msgstr ""

#. ยง0: ```anBnLang```
#. ยง1: ```a```
#. ยง2: ```b```
#: Game.Levels.AnBnNotRegular.L01_CountAEqCountBInLang
msgid "This lemma states that if a word is an element of the language ยง0, then the number of\n"
"occurrences of the character ยง1 equals the number of occurrences of the character ยง2 in\n"
"that word."
msgstr ""

#. ยง0: ```z = $a^n b^n$```
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```u ++ v```
#. ยง3: ```n```
#. ยง4: ```u```
#. ยง5: ```a```
#. ยง6: ```a```
#. ยง7: ```u```
#. ยง8: ```u```
#: Game.Levels.AnBnNotRegular.L06_CountAInU
#: Game.Levels.AnBnNotRegular.L08_CountAInV
msgid "In this level, you will show that when you decompose the word ยง0 as\n"
"ยง1 and the length of ยง2 is at most ยง3, then ยง4 is made of\n"
"only ยง5s. Following this, the count of ยง6s in ยง7 is equal to the length of ยง8."
msgstr ""

#: Game.Levels.AnBnNotRegular.L09_CountBInV
msgid "Well done! In the next level, let's move on to the next proof!"
msgstr ""

#. ยง0: ```drop_replicateChar```
#. ยง1: ```take_replicateChar```
#. ยง2: ```take_replicateChar```
#: Game.Levels.TakeAndDrop.L08_DropReplicateChar
msgid "The proof for ยง0 is analogue to the proof for the counterpart\n"
"ยง1. If you do not know how to proceed you can have a look at the\n"
"proof for ยง2 in the previous level."
msgstr ""

#. ยง0: ```h```
#: Game.Levels.CountCharAndElemOf.L03_CharInAppendLeft
msgid "Now, you can proceed by simplifying your hypothesis ยง0. Any other simplification is\n"
"currently not possible with the given theorems."
msgstr ""

#: Game.Levels.AnBnNotRegular
msgid "AnBn is Not Regular"
msgstr ""

#. ยง0: $z = a^n b^n$
#. ยง1: ```z = (u ++ v) ++ w```
#. ยง2: ```k = length u + length v```
#. ยง3: ```k โค n```
#. ยง4: ```length u < k```
#. ยง5: ```w```
#. ยง6: ```n - k```
#. ยง7: ```a```
#. ยง8: ```n```
#. ยง9: ```b```
#: Game.Levels.AnBnNotRegular.L12_WEqRemainingAsNBs
msgid "For a word ยง0, which is decomposed as ยง1 with\n"
"ยง2, ยง3 and ยง4, the remaining\n"
"suffix ยง5consists of exactly ยง6 replicas of ยง7 followed by\n"
"ยง8 replicas of ยง9."
msgstr ""

#. ยง0: ```n```
#. ยง1: ```n - 0 = n```
#: Game.Levels.TakeAndDrop.L05_TakeAppendRight
msgid "Subtracting zero from a natural number.\n"
"\n"
"For any natural number ยง0, we have ยง1."
msgstr ""

#. ยง0: ```apply Nat.le_add_right n n```
#. ยง1: ```n```
#: Game.Levels.AnBnNotRegular.L11_NumberOfAsInPumpedWord
msgid "Now, you can execute ยง0. This theorem states, that any natural\n"
"number is less than or equal to itself plus another natural number. However, in your case both\n"
"numbers are same so you can pass ยง1 twice."
msgstr ""
